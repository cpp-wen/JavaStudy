![img](https://user-gold-cdn.xitu.io/2019/8/27/16cd0b2d742aaf2d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

![img](https://user-gold-cdn.xitu.io/2019/8/27/16cd0b3260488cb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

减库存 三种方式 

 	下单减库存。买家下单后，扣减商品库存。下单减库存是最简单的减库存方式，也是控制最为精确的一种

​	付款减库存。买家下单后，并不立即扣减库存，而是等到付款后才真正扣减库存。但因为付款时才减库存，如果并发比较高，可能出现买家下单后不能付款的情况，因为商品已经被其他人买走了

​	预扣库存。这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如 15 分钟），超过这段时间，库存自动释放，释放后其他买家可以购买





dao层的主要实现是

使用了联合主键来保证在购买详情表中每次单个用户只能购买一件商品 （如何解决限购问题）

web层 

为什么要定义一个单独的一个接口来获取秒杀地址？

秒杀暴露接口，秒杀开始时输出暴露秒杀地址，否则输出系统时间以及秒杀时间

如何定义一个秒杀的接口

1. 首先需要判断当前 的一个时间，只有在开始和结束之间才暴露秒杀的开始时间
2. 正在秒杀中的时候，就返回当前商品秒杀的url

库存业务落地 

	1. 减少库存
 	2. 记录购买明细

只有当这两个都完成的时候才完成一次完整的操作 作为一个execute方法进行执行

execute方法主要有几个参数分别是 用户手机号 商品id 以及 md5加密值，

通过添加事务来保证超卖以及少卖的情况发生

![img](https://tycoding.cn/2018/10/13/ssm/seckill-service/3.png)

为什么先记录秒杀订单操作然后再执行减库存的操作

因为数据库中减少库存是行锁，这个时候如果多个用户同时进行减少库存，使得那些已经重复购买过的用户也占用了一定的系统资源，所以先进行插入购买信息记录，然后再减少库存，减少了一定的开销



Redis进行缓存的优化 

商品预热，将秒杀的一些商品提前放入到redis中，查询商品也是经常遇到，所以将商品也放入到redis中

每次更新完成 ，就是库存减少1之后，对redis中缓存的当前商品数量也减少1,





秒杀系统的 其他的一些问题记录

前端的设计：

1. 秒杀开始前秒杀按钮为未开始不可以点击
2. 秒杀进行中，秒杀按钮可以点击下单
3. 秒杀结束后，秒杀按钮为已结束，不可点击

