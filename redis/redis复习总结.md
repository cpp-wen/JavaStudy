# redis面试详细知识点总结

redis存储结构

键：只有一种string类型 值有五种：list set zset hash string

rdb和aof两者的优势和缺点 使用的场景 



redis 持久化



redis 高可用 高并发 高性能

高可用 主从复制（sentinel）

高并发 线程模型

高性能   cluster集群



## redis出现问题：

### 缓存雪崩：

缓存一段时间内全部失效，或者redis服务挂了，导致数据全部请求数据库

缓存雪崩 解决方案：

1. 设置主从架构，避免redis服务器挂了
2. 通过网关限流 或者本地缓存 保持服务暂时可用
3. redis重启，使用持久化话文件从硬盘恢复文件



### 缓存穿透：

大量请求参数为非法参数导致请求未命中，导致请求走数据库

缓存穿透 解决方案：

1. 设置布隆过滤器 或者 压缩filter提前拦截
2. 将非法请求设置存入缓存 设置较短过期时间



### 缓存数据库双写一致问题

对于数据库中保存的数据和redis中保存的数据结果不一致

分布式事物问题：

1. 先写redis 后数据库
2. 先数据库 后redis



缓存操作的两种方式

1. 更新缓存
2. 删除缓存

建议使用删除缓存：高并发环境下频繁的修改会导致造成一定的性能消耗 同时 更新缓存更容易出现不一致问题

#### 分布式事物问题优缺点

- 先改数据库后删缓存（cache aside pattern）（并发下表现优异，原子性被破坏时候表现不如意）
- 先删缓存后改数据库（并发下表现不如意，原子性没有被破坏时候表现如意）

1. 小概率出现数据和缓存不一致的问题。 缓存失效 -》a读取数据库值-》b-》修改数据库值-》b删除缓存-》a重置缓存 为旧值

2. 也有数据和缓存不一致问题。 a删除缓存-》b读取数据 -》b读取旧值-》b重设缓存为旧值-》a更新数据库 

解决方法：

串行化操作 将删除 更新操作放入队列中，定时消费

   

### 分布式锁

分布式锁解决主要问题

1. 避免不同节点重复相同工作
2. 避免破坏数据的正确性

锁的时间无法合理确定所以分布式锁不适合任务时间长的情况。

锁要满足的条件：

1. 互斥性
2. 不会发生死锁
3. 具有容错性
4. 加锁和解锁对象为一个

分布式锁版本区别

1. 1.0 

   使用setnx 和exipre 来实现 但是两条命令非原子操作虽然可以通过lua脚本来同步实现 但是在发生主从替换的时候 仍然会发生死锁情况

2. 1.1

   基于GETSET实现  key为id ，value为时间戳，通过setnx获取锁，如果获取锁失败通过get操作获取时间戳，判断当前时间是否过期，如果过期就重新设置新的过期时间，获取最后旧的值，判断是否成功

3. 2.0

   采用setnx 作为一条命令解决原子性 问题，最终导致gc时候多个线程重复获得锁，造成数据的不一致问题

4. 3.0

   将 value 设置为时间戳，释放锁的时候判断是否为当前释放锁的value是否是获取锁的value

5. 3.1

   目前使用最广泛的方式 使用set代替setnx，使用自增的uniqueID代替时间戳 解决3.0中出现时间戳重复的问题。  在集群环境下 异步同步的时候会发生主节点crash且 未同步导致多个client客户端同时获取到了同一个锁

6. 分布式锁:redlock

   尝试向多个redis节点获取锁，中间拥有获取锁超时（以及锁被其他客户端拥有）的情况，则跳过，如果当前服务获取到n/2+1个redis 集群的锁的时候，并且时间消耗没有超过锁的有效时间 ，就判断成功获取到锁，这个时候有效时间减去中间消耗时间计算成为总时间。










> 拓展：
>
> GC导致多个线程获得锁出现 锁不安全情况
>
> ![img](https://camo.githubusercontent.com/dabb9223848c1297181c876cc99f1448fa50a4a2/68747470733a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f373839363839302d636633613430333936386132336265342e706e673f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430)
>
> 