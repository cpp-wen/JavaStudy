# 阿里云开发者中心面试算法

## 数组变化

概述：

给出一个长度为 n 的数组，和一个正整数 d。

你每次可以选择其中任意一个元素 a[i] 将其变为 a[i] + d 或 a[i] - d，这算作一次操作。你需要将所有的元素全部变成相等元素，如果有解，请输出最小操作次数，如果无解请输出-1。
输入数字n、数字d，和一个长度为n的数组a。1 <= n <= 100000，1 <= d <= 100, 1 <= a[i] <= 100000。
输出一个数字，表示最小的操作次数，如果无解输出-1。

示例1

**输入：**
5
2
[3,5,7,1,9]
**输出：**
6



注意

最优解为全部变为5，共1 + 0 + 1 + 2 + 2 = 6次。



算法题解思路：

首先判断无解的情况，可以发现 a[i]，a[i]+d, a[i]-d 在 模 d 情况下的余数不会发生 改变，因此如果原数组中的存在任意两个数字它们对 d 取余结果不同，那么此时无解。 设余数为 r。判断完无解之后，需要求出最小值。 先将数组 a[i] 排序，然后除以 d，得到从 r 变成 a[i] 需要的步数。 枚举元素 a[i]，将所有元素全部变成 a[i] 需要考虑两部分，i 之前和 i 之后 : 对于 i 之前的元素，假设都是 r，那么需要 (i-1)*a[i]，但是因为并不都是 0，所有我们可以 用一个变量 val 存放前 i-1 项的和，然后我们在减去 val 就是前 i-1 个元素真正需要 操作的步数。 对于 i 之后的元素，也是类似的。我们假设 i 之后的所有项和为 val，假设我 们要将它们变为 r，则消耗即为 val，但是我们只需要将其变为 a[i]，因此需要减去 (n-i)*a[i]。

个人思考总结：

1. 先判断数组元素求余r是否都相同

2. 排序按照 从小到大 

3. 创建一个前缀和 记录数组和

4. for循环遍历 以每个元素作为基值 进行计算次数 同时记录最小值

   1. 左边次数计算为（到i的前缀和 - (i-1)*a[i]）/r
   2. 右边次数计算为（（n-i）*a[i] -i到n前缀和的差值 ）/r

   记录最小值







## 打怪兽

现在有3只怪兽，他们的都有自己的血量a,b,c(1<=a,b,c<=100)，当Tom打死第一怪兽的时候花费的代价为0，其余的怪兽的代价为当前的怪兽的血量减去上一个怪兽的血量的绝对值。问Tom打死这些怪兽所需要的最小代价
分别输入三只怪兽的血量
输出打死三只怪兽的最小代价



示例1

**输入：**
2
5
8
**输出：**
6





解题思路：贪心
根据题意，本题使用贪心算法完成，策略是每次打怪兽都选择代价最小的一只。
由于第一次打怪兽的花费为 0，所以第一次可以打血量最小的（最大的也可以），
接下来每次选择怪兽的时候就可以选择花费代价最小的。由于每次打怪兽的代价都
是：当前怪兽的血量和上一个怪兽的血量的差的绝对值。于是可以得出结论，最小代
价为所有怪兽血量的最大值减最小值。



个人总结：

打怪兽 标签是贪心但是重点还是排序的一个思想，无论是从大到小还是从小到大。只要是数组是有序的就可以通过相邻两位元素相减求和的方式进行计算。利用数学的思想 可以简化为最大值减最小值，就是最后结果。





现在有n个点(1<=n<=1000)，每个点都有一个值称为点权ai(ai为偶数，1<=ai<=1000)，现在可以将任意两个点相连，连起来以后这条边也有一个值称为边权，这个边的边权为这两个点的点权之和的一半。现在需要你添加n-1条边，问将这n个点连通以后(连通是指任意两个点都能互相到达)的最大的边权和是多少。
输入点的数量n；和n个数，表示点权的值
输出最大的边权和



示例1

**输入：**
5
[2,4,6,8,10]
**输出：**
30



解题思路：

根据题意，最终需要将 n 个点连通并达到最大边权，而边权为两个点的点权之和
的一半，所以一个点加入连通图的最大边权就是和点权最大的点连通。
因此想要得到最大边权和，只要所有点都与点权最大的点相连即可。
实现过程中，首先求出最大的点权，然后计算出其他点与这个权值最大的点的边
权之和即可。

个人总结：

每个点和最大的节点相互连接就可以了 贪心的一个思想。





## 最强团队

概述：

有一个阵营，里面有n个小队(1<=n<=100)，每个小队都有他们的能力值ai(0<=i<n)。



现在有一个紧急情况，需要从这些小队中选出连续的几个小队，组成一个最强的团队。最强的团队的定义为这个团队的所有小队的平均能力值最高。如果有多个最强团队，则选包含小队最多的一个。



现在请你写个程序，输出这个最强的团队包含的小队的个数。

输入小队的数量n，和n个数，分别代表各小队的能力值ai

输出一个数表示这个最强团队包含的小队的个数



示例1

**输入：**
6
[1,2,3,3,2,1]
**输出：**
2



总结

根据题意，最强团队即团队中每个小队的能力值都是最高的。即解决这道题需要
找出数组中连续最大值的个数，若有多个连续最大值，选择个数最多的。
具体实现时，可以先找出数组中最大的能力值是多少，然后设置一个标记tag。
接着遍历数组，比较每个数组元素和最大值，数组元素等于最大的值的时候，将 tag
标记为 1，数组元素不等于最大值时，将 tag 置为 0。
在 tag 等于 1 时统计连续最大值的数量，若统计到多个最大值，则记录最大的
那个。



个人理解：

先找到最大的值，进行标记 然后遍历数组  只有后一个数组元素也等于最大值的时候，这个时候结果长度才会上升。否则单个最大元素平均值可能是比多个元素平均值大的。





## Tom爱吃巧克力

Tom非常喜欢巧克力，他上次买的巧克力吃完了，所以他打算再去买k块巧克力回来(1<=k<=1e5)，他又是一个非常节俭的一个人，所以他想花最少的钱去买巧克力，现在有n家卖巧克力的店(1<=n<=1e5)，每个店的巧克力都限购bi块(最多只能买bi块,1<=bi<=1e5)，每块的价格是ai(1<=ai<=1e9)，请问Tom买k块巧克力最少要花多少钱。题目保证n个bi的总和大于等于k。
输入卖巧克力的店的个数n(1<=n<=1e5)；打算去买的巧克力块数k(1<=k<=1e5)；和一个数组m,其中mi =`[ai, bi]` (1<=ai<=1e9,1<=bi<=1e5 )表示第i家巧克力店的巧克力的价格和限购块数
输出一个数，表示Tom买k块巧克力花的最少钱数



示例1

**输入：**
2
5
[[4,5],[2,4]]
**输出：**
12



思路：

根据题意，可以得知这道题可以运用贪心算法，策略是每次都去买最便宜的巧
克力。
由于题目给的二维数组是乱序的，可以根据巧克力的价格对二维数组从小到大进
行排序，便于	Tom	选择最便宜的巧克力。Arrays	类中只提供了一维数组的排序，如
果要用 Arrays 对二维数组排序，需要重写 Comparator 里的 compare 方法。
排序完成后，接下来操作就比较简单了。遍历数组，优先买便宜的巧克力，直到
达到限购块数，再去下一家巧克力店。最终买到	k	块巧克力时	Tom	花的钱最少

个人总结：

其实就是对二维数组按照价格进行一个排序之后再按照排序不断进行购买 算出最后的一个结果就可以了





## 吃奶酪

om和Jerry都很喜欢吃奶酪，现在有n块奶酪散落在坐标轴上(1<=n<=100000)，他们分别在a1,a2,a3...an(1<=ai<=100000,一个点可以有多块奶酪)上，Tom和Jerry分别在1和100000两个点上，他们每走一步需要花费1s，问他们拿到所有的奶酪至少要花费多少时间
输入奶酪数量n，和n个奶酪的坐标
输出一个数，表示他们拿到所有奶酪所用的最短时间



示例1

**输入：**
4
[350,2000,80000,99999]
**输出：**
20000



题解：

根据题意，如果要花费最少时间，则每个奶酪都让离奶酪最近的人去拿，因此，
坐标 <=50000 的奶酪让 Tom 去拿，坐标 >=50001 的奶酪让 Jerry 去拿。
具体实现时，可以设置一个 time 值，然后遍历数组。判断每一块奶酪的坐标范
围，根据坐标判断应该让谁拿，再计算拿到这个奶酪需要多长时间，如果时间大于
time，则用这个值替换掉 time 的值。
用这种方法，遍历整个数组后的 time 值即为	Tom	和	Jerry	拿到所有奶酪所用
的最短时间。
时间复杂度：O(n)
空间复杂度：O(1)



个人总结：这边给的是x轴，并不是一个二维的空间所以不用考虑回退的一些情况，直接按照上面官方给的题解，直接O(n)遍历就可以获得结果





## 一的个数

题目描述

提交记录

概述：

给你两个数字l、r，问在区间[l,r]内的所有数中，二进制表示下“1”的个数最多的一个数是多少，如果有多个相同的，输出所有符合条件的数中最小的一个数。
输入一个整数l,和一个整数r。(1<=l<=r<=10^9)
输出一个数字表示[l,r]内二进制下“1”的个数最多的数。如果有多个，输出符合条件的数中最小的。



示例1

**输入：**
5
10
**输出：**
7





题解：

根据题意，本题的所有数字应从二进制角度考虑。
所求数字可分为两部分，高位部分和低位部分，高位部分的值等于 l,	r 高位相等
的部分，在区间 [l,r] 中的所有数的高位部分都应该与其相等，即
high	=	r	&	(-1<
低位的部分计算过程如下：
如果	r-high	的值的二进制全为 1，则低位部分为	r-high。如果不是全为 1，则
低位部分为
(	1<<(count-1)	)	-	1
时间复杂度：O(log_2	n)
空间复杂度：O(1)

个人题解：

上面官方的题解比较垃圾，直接表达可以为从l开始，对于这个l的二进制的位数不断将最末尾的一个0变成1，变成1之后，产生进位不断相比，唯一需要注意的不能大于r。下面是代码

l|l+1 经过两次转换之后一定会变成小于2的幂的一个数。也就是没经过一次循环 1的个数就增加1个

```java
class Solution {
    public int solution(int l, int r) {
       while((l | l + 1) <= r) {
         l |= (l + 1);
       }
       return l;
    }
}
```



## Bob的花束

Bob和Alice是青梅竹马。
今天，Bob终于要鼓起勇气向Alice表白了！
说到表白，自然是少不了买花了。Bob来到了花店，花店一共提供了9种花，每一种花都有对应的价钱。但是Bob的零花钱有限，不能把所有的花都买下来送给Alice。
为了方便挑选，Bob给这9种花分别标号1-9，Bob希望买到的花按照编号可以排出尽可能大数字，请问Bob能够排出的最大的数字是多少？
输入一个正整数value，代表Bob拥有的零花钱。(0<=value<=10^6)
和有9个数字的数组a，ai代表第i种花的价格。(1<=ai<=10^5,1<=i<=9)
输出一个数字，表示Bob可以排出的最大数字。如果Bob不能排出任何一个数字，则输出-1。



题解：

本题充分理解题意后，直接模拟这个“选取最大值”的过程就可以得到结果了。
首先，选取最大值，意味着首先这个结果的“位数”要足够多，比如假设所有的
花价格都是 1 元钱，则 11111111 是花 9 块钱能买到的最大值，而不是 333 或者 9
这样的方案。这样相当于根据输入，输出的位数可以用很小的时间代价来确定：“用可
用钱数，除以最便宜的花的价格，并向下取整”。假设这里的位数为 m。
其次，在位数确定的情况下，高位数字越大，结果也就越大，比如同样是8元
钱，只能购买价格为5的5号花，和价格为3的3号花时，购买35就是最差的方
案，而 53 才是正确答案。而且因为每个花的数量是无限的，所以可以模拟这个	“从
高位开始，逐个选取能买得起的最大的数字；同时每选完一位后，要确保剩下的钱，
依旧可以买到 m 位数字的组合方案。”
提示：	根据上面逻辑写出的答案，在充分理解优化后，至少可以达到 2 遍扫描数
组得到结果。
时间复杂度：O(9n)



个人总结：

步骤先计算出整体全部最大的位数，然后将从高位到低位进行排序计算，计算的时候要确保从高位到低位取整 所以需要时间的一个复杂度是O(9n)



## 钱庄

钱庄每天能够收到很多散钱，第i个散钱的值2^wi。为了便于管理，钱庄每天都会向中央银行申请兑换钱币，假设钱庄有一些散钱使得2^k1+2^k2+...+2^km=2^x（x为非负整数），那么就可以将这些散钱兑换成一个大钱币，问在钱庄收到的这些散钱最终最少能变成几个钱币。
输入一个整数n，表示一共有n个钱币(1 <= n <= 10^6)；再输入n个整数wi，表示有价值2^wi(0 <= wi <= 10^6)的钱币。
输出兑换后最少的钱币数



示例1

**输入：**
4
[1, 1, 2, 3]
**输出：**
1



注意

2^1+2^1+2^2+2^3=2^4，因此兑换后最少为一个钱币



官方题解：

大致思路：对于 [1,	1,	2,	3] 样例，答案 1 是怎么算出来的？按照题目的思路，应
该这样算：2^1+2^1+2^2+2^3=2^4, 因此为 1，但是如果这样做，肯定会超时，我是
这样算的：对于底数为 2 幂数相同的两个数想加，是不是底数不变，幂加 1，因此两
个 1 组成一个 2，此时共有两个 2，这两个 2 组成一个 3，此时共有两个 3，两个三
组成一个 4，最后只剩一个 4，因此答案为 1.
具体过程：遍历一遍m找出m中的最大数max，定义一个数组arr[max+2],
用于统计出m数组中，每个数字出现的次数，即arr[m[i]]++（m中的元素为下标，
arr 数组中保存出现的次数）;
再次遍历 arr 数组 (0<=i<=max)，如果当前元素 arr[i]==0，那就下一个，
如果不为 0，arr[i+1]+=arr[i]/2;( 每两个 arr[i] 就能凑一个 arr[i+1])
如果 arr[i] 为奇数，那说明剩余一个 arr[i]，这最后也就剩下了，所以 ans++；
遍历完后 if(arr[max+1]!=0)	ans++; 然后 return	ans;



官方题解2：

利用从底向上进行递归调用 不断兑换，直到无法兑换 这种时间复杂度会很高



总结：

有点利用数学 思想配合桶排序 计算 

