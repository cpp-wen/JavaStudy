# 阿里云开发者中心面试算法

## 数组变化

概述：

给出一个长度为 n 的数组，和一个正整数 d。

你每次可以选择其中任意一个元素 a[i] 将其变为 a[i] + d 或 a[i] - d，这算作一次操作。你需要将所有的元素全部变成相等元素，如果有解，请输出最小操作次数，如果无解请输出-1。
输入数字n、数字d，和一个长度为n的数组a。1 <= n <= 100000，1 <= d <= 100, 1 <= a[i] <= 100000。
输出一个数字，表示最小的操作次数，如果无解输出-1。

示例1

**输入：**
5
2
[3,5,7,1,9]
**输出：**
6



注意

最优解为全部变为5，共1 + 0 + 1 + 2 + 2 = 6次。



算法题解思路：

首先判断无解的情况，可以发现 a[i]，a[i]+d, a[i]-d 在 模 d 情况下的余数不会发生 改变，因此如果原数组中的存在任意两个数字它们对 d 取余结果不同，那么此时无解。 设余数为 r。判断完无解之后，需要求出最小值。 先将数组 a[i] 排序，然后除以 d，得到从 r 变成 a[i] 需要的步数。 枚举元素 a[i]，将所有元素全部变成 a[i] 需要考虑两部分，i 之前和 i 之后 : 对于 i 之前的元素，假设都是 r，那么需要 (i-1)*a[i]，但是因为并不都是 0，所有我们可以 用一个变量 val 存放前 i-1 项的和，然后我们在减去 val 就是前 i-1 个元素真正需要 操作的步数。 对于 i 之后的元素，也是类似的。我们假设 i 之后的所有项和为 val，假设我 们要将它们变为 r，则消耗即为 val，但是我们只需要将其变为 a[i]，因此需要减去 (n-i)*a[i]。

个人思考总结：

1. 先判断数组元素求余r是否都相同

2. 排序按照 从小到大 

3. 创建一个前缀和 记录数组和

4. for循环遍历 以每个元素作为基值 进行计算次数 同时记录最小值

   1. 左边次数计算为（到i的前缀和 - (i-1)*a[i]）/r
   2. 右边次数计算为（（n-i）*a[i] -i到n前缀和的差值 ）/r

   记录最小值







## 打怪兽

现在有3只怪兽，他们的都有自己的血量a,b,c(1<=a,b,c<=100)，当Tom打死第一怪兽的时候花费的代价为0，其余的怪兽的代价为当前的怪兽的血量减去上一个怪兽的血量的绝对值。问Tom打死这些怪兽所需要的最小代价
分别输入三只怪兽的血量
输出打死三只怪兽的最小代价



示例1

**输入：**
2
5
8
**输出：**
6





解题思路：贪心
根据题意，本题使用贪心算法完成，策略是每次打怪兽都选择代价最小的一只。
由于第一次打怪兽的花费为 0，所以第一次可以打血量最小的（最大的也可以），
接下来每次选择怪兽的时候就可以选择花费代价最小的。由于每次打怪兽的代价都
是：当前怪兽的血量和上一个怪兽的血量的差的绝对值。于是可以得出结论，最小代
价为所有怪兽血量的最大值减最小值。



个人总结：

打怪兽 标签是贪心但是重点还是排序的一个思想，无论是从大到小还是从小到大。只要是数组是有序的就可以通过相邻两位元素相减求和的方式进行计算。利用数学的思想 可以简化为最大值减最小值，就是最后结果。





现在有n个点(1<=n<=1000)，每个点都有一个值称为点权ai(ai为偶数，1<=ai<=1000)，现在可以将任意两个点相连，连起来以后这条边也有一个值称为边权，这个边的边权为这两个点的点权之和的一半。现在需要你添加n-1条边，问将这n个点连通以后(连通是指任意两个点都能互相到达)的最大的边权和是多少。
输入点的数量n；和n个数，表示点权的值
输出最大的边权和



示例1

**输入：**
5
[2,4,6,8,10]
**输出：**
30



解题思路：

根据题意，最终需要将 n 个点连通并达到最大边权，而边权为两个点的点权之和
的一半，所以一个点加入连通图的最大边权就是和点权最大的点连通。
因此想要得到最大边权和，只要所有点都与点权最大的点相连即可。
实现过程中，首先求出最大的点权，然后计算出其他点与这个权值最大的点的边
权之和即可。

个人总结：

每个点和最大的节点相互连接就可以了 贪心的一个思想。