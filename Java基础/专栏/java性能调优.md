# 01 | 如何制定性能调优标准？

其实，在项目开发的初期，我们没有必要过于在意性能优化，这样反而会让我们疲于性能优化，不仅不会给系统性能带来提升，还会影响到开发进度，甚至获得相反的效果，给系统带来新的问题。

## 有哪些参考因素可以体现系统的性能？

**CPU**：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。

**内存**：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。

**磁盘 I/O**：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。

**网络**：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。

**异常**：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。

**数据库**：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。

**锁竞争**：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。

## 响应时间

响应时间是衡量系统性能的重要指标之一，响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。在系统中，我们可以把响应时间自下而上细分为以下几种：

- 数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；
- 服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；
- 网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；
- 客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。

# 02 | 如何制定性能调优策略？

## 性能测试攻略

**1. 微基准性能测试**

微基准性能测试可以精准定位到某个模块或者某个方法的性能问题，特别适合做一个功能模块或者一个方法在不同实现方式下的性能对比。例如，对比一个方法使用同步实现和非同步实现的性能。

**2. 宏基准性能测试**

宏基准性能测试是一个综合测试，需要考虑到测试环境、测试场景和测试目标。



## **性能测试需要注意问题**

1. **热身问题** java虚拟机将热点程序进行即时编译器，将代码保存到内存中提升了系统后期运行速度，但是热点程序代码的编译需要长时间的优化
2. **性能测试结果不稳定** 由于网络机器等许多原因，导致每个阶段测试结果有一定误差
3. **多 JVM 情况下的影响**  一台机器上部署多个jvm 

## 调优的几种方法

1. 优化代码 如将LinkedList迭代转换为 使用迭代器模式
2. 优化设计 使用设计模式 如单例模式享元模式
3. 优化算法
4. 空间换时间
5. 时间换空间
6. 参数调优 设计jvm参数信息 减少频繁gc



![image-20200508002350642](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200508233655.png)



# 03 | 字符串性能优化不容小觑，百M内存轻松存储几十G数据

**String 对象是如何实现的？**

![image-20200509223036648](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200509223038.png)

**1. 在 Java6 以及之前的版本中**，String 对象是对 char 数组进行了封装实现的对象，主要有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。

String 对象是通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。

**2. 从 Java7 版本开始到 Java8 版本**，Java 对 String 类做了一些改变。String 类中不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。

**3. 从 Java9 版本开始，**工程师将 char[] 字段改为了 byte[] 字段，又维护了一个新的属性 coder，它是一个编码格式的标识。coder 属性默认有 0 和 1 两个值，0 代表 Latin-1（单字节编码），1 代表 UTF-16。如果 String 判断字符串只包含了 Latin-1，则 coder 属性值为 0，反之则为 1。

**String 对象的优化**

java内部编译器会使用StringBuilder对两个string类相互拼接时候进行一个优化

```java
//原来的形式
string a="aaa"+"bbb"+"cccc";
//优化后形式
string a="aaabbbccc";
```

如果有多个字符串要进行拼接，这个时候java底层会使用builder对代码优化 

![image-20200509223929926](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509223929926.png)

![image-20200509223941501](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509223941501.png)

所以在自己实现代码的时候 可以直接创建一个builder对象 对代码进行一个优化，避免重复创建builder对象。

**如何使用 String.intern 节省内存？**

使用intern()方法将常用字符串保存到常量池中,复用常量池中字符串的引用。使得堆中没有对象引用的字符串被虚拟机进行垃圾回收。减少jvm内存空间的消耗。

![image-20200509224325765](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509224325765.png)

常量池使用的是Hashtable类似的结构 ，那么如果常量池的数据量过大，这个时候查找对性能也会有一定的影响。



**如何使用字符串的分割方法**

字符串的分割方法跟split()方法有关系，split()进行正则表达式的时候 会根据表达式的情况进行发生贪婪独占回溯的三种情况。对性能也会有一定的影响。可以考虑使用indexOf()来替代进行数据的查找。



优质评论 

1. java6中 使用subString()方法获取一个子字符串，内部修改的是offset指针指向的下标，导致当前char数组并没有被回收使得内存泄露，如果有大量的通过subString()方法从大字符串数组中获取 一小部分字符串的时候，会因为内存泄露导致内存溢出。



# 04 | 慎重使用正则表达式

表达式 的优化主要跟三种模式有关系，具体使用场景具体优化。尽量避免使用。

# 05 | ArrayList还是LinkedList？使用不当性能差千倍

为什么Arraylist中实现了序列化的接口但是在数组前面添加了transient 修饰符，不对数组进行序列化。因为ArrayList对数组长度是进行动态扩增的，所创建的空间并不一定被充分使用，所以在内部提供了两个私有方法wirteObject和readObject实现自我完成序列化和反序列化 ，从而在序列化和反序列化数组时节省了空间和时间。



使用ArrayList 的构造方法的提前初始化数组的长度，避免多次动态进行数组容量的扩容。数组扩容方式是使用1,5倍进行扩容的。扩容后调用Arrays.copy方法进行数组复制



两种链表比较的时候考虑插入和删除分别在不同位置的区别,以及从缓存不友好的角度进行分析.

头部插入  头部删除

中间插入  中间删除

尾部插入  尾部删除

性能比较Arraylist 在头部插入的效率不如LinkedList，而中间和尾部插入的效率ArrayList大于LinkedList。(以上场景是根据ArrayList不进行数组扩容的情况下进行分析的场景)[删除效率相同]



链表进行元素删除的时候要注意使用使用的哪种迭代方式，如果是使用迭代器迭代那么使用迭代的时候如果调用链表本身的remove方法会报出exceptedModcountException异常，使用迭代器的方法就没有这个问题。使用原生的for方法进行remove的时候这个时候，因为调用remove方法的时候会复制后面一个元素往前面移动同时i增大，这个时候会发生原先 应该遍历 元素未被遍历 产生遗漏。















































