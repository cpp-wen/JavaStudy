# 01 | 如何制定性能调优标准？

其实，在项目开发的初期，我们没有必要过于在意性能优化，这样反而会让我们疲于性能优化，不仅不会给系统性能带来提升，还会影响到开发进度，甚至获得相反的效果，给系统带来新的问题。

## 有哪些参考因素可以体现系统的性能？

**CPU**：有的应用需要大量计算，他们会长时间、不间断地占用 CPU 资源，导致其他资源无法争夺到 CPU 而响应缓慢，从而带来系统性能问题。例如，代码递归导致的无限循环，正则表达式引起的回溯，JVM 频繁的 FULL GC，以及多线程编程造成的大量上下文切换等，这些都有可能导致 CPU 资源繁忙。

**内存**：Java 程序一般通过 JVM 对内存进行分配管理，主要是用 JVM 中的堆内存来存储 Java 创建的对象。系统堆内存的读写速度非常快，所以基本不存在读写性能瓶颈。但是由于内存成本要比磁盘高，相比磁盘，内存的存储空间又非常有限。所以当内存空间被占满，对象无法回收时，就会导致内存溢出、内存泄露等问题。

**磁盘 I/O**：磁盘相比内存来说，存储空间要大很多，但磁盘 I/O 读写的速度要比内存慢，虽然目前引入的 SSD 固态硬盘已经有所优化，但仍然无法与内存的读写速度相提并论。

**网络**：网络对于系统性能来说，也起着至关重要的作用。如果你购买过云服务，一定经历过，选择网络带宽大小这一环节。带宽过低的话，对于传输数据比较大，或者是并发量比较大的系统，网络就很容易成为性能瓶颈。

**异常**：Java 应用中，抛出异常需要构建异常栈，对异常进行捕获和处理，这个过程非常消耗系统性能。如果在高并发的情况下引发异常，持续地进行异常处理，那么系统的性能就会明显地受到影响。

**数据库**：大部分系统都会用到数据库，而数据库的操作往往是涉及到磁盘 I/O 的读写。大量的数据库读写操作，会导致磁盘 I/O 性能瓶颈，进而导致数据库操作的延迟性。对于有大量数据库读写操作的系统来说，数据库的性能优化是整个系统的核心。

**锁竞争**：在并发编程中，我们经常会需要多个线程，共享读写操作同一个资源，这个时候为了保持数据的原子性（即保证这个共享资源在一个线程写的时候，不被另一个线程修改），我们就会用到锁。锁的使用可能会带来上下文切换，从而给系统带来性能开销。JDK1.6 之后，Java 为了降低锁竞争带来的上下文切换，对 JVM 内部锁已经做了多次优化，例如，新增了偏向锁、自旋锁、轻量级锁、锁粗化、锁消除等。而如何合理地使用锁资源，优化锁资源，就需要你了解更多的操作系统知识、Java 多线程编程基础，积累项目经验，并结合实际场景去处理相关问题。

## 响应时间

响应时间是衡量系统性能的重要指标之一，响应时间越短，性能越好，一般一个接口的响应时间是在毫秒级。在系统中，我们可以把响应时间自下而上细分为以下几种：

- 数据库响应时间：数据库操作所消耗的时间，往往是整个请求链中最耗时的；
- 服务端响应时间：服务端包括 Nginx 分发的请求所消耗的时间以及服务端程序执行所消耗的时间；
- 网络响应时间：这是网络传输时，网络硬件需要对传输的请求进行解析等操作所消耗的时间；
- 客户端响应时间：对于普通的 Web、App 客户端来说，消耗时间是可以忽略不计的，但如果你的客户端嵌入了大量的逻辑处理，消耗的时间就有可能变长，从而成为系统的瓶颈。

# 02 | 如何制定性能调优策略？

## 性能测试攻略

**1. 微基准性能测试**

微基准性能测试可以精准定位到某个模块或者某个方法的性能问题，特别适合做一个功能模块或者一个方法在不同实现方式下的性能对比。例如，对比一个方法使用同步实现和非同步实现的性能。

**2. 宏基准性能测试**

宏基准性能测试是一个综合测试，需要考虑到测试环境、测试场景和测试目标。



## **性能测试需要注意问题**

1. **热身问题** java虚拟机将热点程序进行即时编译器，将代码保存到内存中提升了系统后期运行速度，但是热点程序代码的编译需要长时间的优化
2. **性能测试结果不稳定** 由于网络机器等许多原因，导致每个阶段测试结果有一定误差
3. **多 JVM 情况下的影响**  一台机器上部署多个jvm 

## 调优的几种方法

1. 优化代码 如将LinkedList迭代转换为 使用迭代器模式
2. 优化设计 使用设计模式 如单例模式享元模式
3. 优化算法
4. 空间换时间
5. 时间换空间
6. 参数调优 设计jvm参数信息 减少频繁gc



![image-20200508002350642](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200508233655.png)



# 03 | 字符串性能优化不容小觑，百M内存轻松存储几十G数据

**String 对象是如何实现的？**

![image-20200509223036648](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200509223038.png)

**1. 在 Java6 以及之前的版本中**，String 对象是对 char 数组进行了封装实现的对象，主要有四个成员变量：char 数组、偏移量 offset、字符数量 count、哈希值 hash。

String 对象是通过 offset 和 count 两个属性来定位 char[] 数组，获取字符串。这么做可以高效、快速地共享数组对象，同时节省内存空间，但这种方式很有可能会导致内存泄漏。

**2. 从 Java7 版本开始到 Java8 版本**，Java 对 String 类做了一些改变。String 类中不再有 offset 和 count 两个变量了。这样的好处是 String 对象占用的内存稍微少了些，同时，String.substring 方法也不再共享 char[]，从而解决了使用该方法可能导致的内存泄漏问题。

**3. 从 Java9 版本开始，**工程师将 char[] 字段改为了 byte[] 字段，又维护了一个新的属性 coder，它是一个编码格式的标识。coder 属性默认有 0 和 1 两个值，0 代表 Latin-1（单字节编码），1 代表 UTF-16。如果 String 判断字符串只包含了 Latin-1，则 coder 属性值为 0，反之则为 1。

**String 对象的优化**

java内部编译器会使用StringBuilder对两个string类相互拼接时候进行一个优化

```java
//原来的形式
string a="aaa"+"bbb"+"cccc";
//优化后形式
string a="aaabbbccc";
```

如果有多个字符串要进行拼接，这个时候java底层会使用builder对代码优化 

![image-20200509223929926](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509223929926.png)

![image-20200509223941501](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509223941501.png)

所以在自己实现代码的时候 可以直接创建一个builder对象 对代码进行一个优化，避免重复创建builder对象。

**如何使用 String.intern 节省内存？**

使用intern()方法将常用字符串保存到常量池中,复用常量池中字符串的引用。使得堆中没有对象引用的字符串被虚拟机进行垃圾回收。减少jvm内存空间的消耗。

![image-20200509224325765](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200509224325765.png)

常量池使用的是Hashtable类似的结构 ，那么如果常量池的数据量过大，这个时候查找对性能也会有一定的影响。



**如何使用字符串的分割方法**

字符串的分割方法跟split()方法有关系，split()进行正则表达式的时候 会根据表达式的情况进行发生贪婪独占回溯的三种情况。对性能也会有一定的影响。可以考虑使用indexOf()来替代进行数据的查找。



优质评论 

1. java6中 使用subString()方法获取一个子字符串，内部修改的是offset指针指向的下标，导致当前char数组并没有被回收使得内存泄露，如果有大量的通过subString()方法从大字符串数组中获取 一小部分字符串的时候，会因为内存泄露导致内存溢出。



# 04 | 慎重使用正则表达式

表达式 的优化主要跟三种模式有关系，具体使用场景具体优化。尽量避免使用。

# 05 | ArrayList还是LinkedList？使用不当性能差千倍

为什么Arraylist中实现了序列化的接口但是在数组前面添加了transient 修饰符，不对数组进行序列化。因为ArrayList对数组长度是进行动态扩增的，所创建的空间并不一定被充分使用，所以在内部提供了两个私有方法wirteObject和readObject实现自我完成序列化和反序列化 ，从而在序列化和反序列化数组时节省了空间和时间。



使用ArrayList 的构造方法的提前初始化数组的长度，避免多次动态进行数组容量的扩容。数组扩容方式是使用1,5倍进行扩容的。扩容后调用Arrays.copy方法进行数组复制



两种链表比较的时候考虑插入和删除分别在不同位置的区别,以及从缓存不友好的角度进行分析.

头部插入  头部删除

中间插入  中间删除

尾部插入  尾部删除

性能比较Arraylist 在头部插入的效率不如LinkedList，而中间和尾部插入的效率ArrayList大于LinkedList。(以上场景是根据ArrayList不进行数组扩容的情况下进行分析的场景)[删除效率相同]



链表进行元素删除的时候要注意使用使用的哪种迭代方式，如果是使用迭代器迭代那么使用迭代的时候如果调用链表本身的remove方法会报出exceptedModcountException异常，使用迭代器的方法就没有这个问题。使用原生的for方法进行remove的时候这个时候，因为调用remove方法的时候会复制后面一个元素往前面移动同时i增大，这个时候会发生原先 应该遍历 元素未被遍历 产生遗漏。



# 06 | Stream如何提高遍历集合效率？

应用场景，对于分库分表的数据如果想要在应用层进行重新排序，使用传统的迭代器方式没有stream流的方式效率高，并且代码优美。

如何实现效率高？

透过 Stream 源码剖析 Stream 的实现原理

![image-20200510222534549](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200510222534549.png)

stream高效的主要原因是他将数据的操作分为两个不同的部分

- 中间操作(懒操作) 对数据流中的数据进行记录并返回一个流，不进行计算操作
  - 无状态：当前流中数据跟上一个执行操作无关
  - 有状态：当前操作受之前操作的影响，只有当数据全部返回时才能进行操作
- 终结操作  计算操作
  - 短路操作：通过某些条件可以获得最终符合条件的结果
  - 非短路操作: 只有处理完所有元素才能得到最终的结果



todo 这块有点难懂



# 07 | 深入浅出HashMap的设计与优化

那么哈希表是怎么解决的呢？方式有很多，比如，开放定址法、再哈希函数法和链地址法。

开放定址法 在扩容以及查找的时候效率并不高

再哈希法 在发生冲突的时候多个进行hash函数运算 降低程序效率

链地址法 比较综合

扰动函数的作用：打乱hashcode真正参加运算的低16位操作

# 08 | 网络通信优化之I/O模型：如何解决高并发下I/O瓶颈？

“**不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？**”

我们知道字符到字节必须经过转码，这个过程非常耗时，如果我们不知道编码类型就很容易出现乱码问题。所以 I/O 流提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。

多次内存复制

三个空间 

用户空间

内核空间

磁盘

![image-20200510233842197](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200510233842197.png)



java中进行优化的主要方向

1. 用缓冲区优化读写操作(nio基于block来实现文件的读取，oio基于流来实现文件读取的)

2. 使用directBuffer减少内存的复制（修改原先在jvm上分配的内存空间直接在物理空间上进行分配）直接将文件复制从内存空间复制到外部设备，减少数据的拷贝。

3. 避免阻塞，优化io操作（这边刚好解决了在看的一些问题）

   传统的文件复制需要进行用户态到内核态的转换以及两次文件复制，内核空间调用的是操作系统的函数进行进行读取以及写入。如果发生大量的操作这个时候会十分占用cpu，为此操作系统引入DMA（直接存储器存储）内核空间与磁盘空间之间的存储全部由DMA负责，但是DMA也要像cpu申请权限，利用DMA总线来实现数据的复制。如果DMA总线过多也会发生总线冲突。

   通道channel有自己的处理器，可以完成磁盘空间到内核空间之间io 操作，同时channel是双向的。读写可以同时进行。

   > 一个设备接口试图通过总线直接向外部设备(磁盘)传送数据时，它会先向CPU发送DMA请求信号。外部设备(磁盘)通过DMA的一种专门接口电路――DMA控制器（DMAC），向CPU提出接管总线控制权的总线请求，CPU收到该信号后，在当前的总线周期结束后，会按DMA信号的优先级和提出DMA请求的先后顺序响应DMA信号。CPU对某个设备接口响应DMA请求时，会让出总线控制权。于是在DMA控制器的管理下，磁盘和存储器直接进行数据交换，而不需CPU干预。数据传送完毕后，设备接口会向CPU发送DMA结束信号，交还总线控制权。
   >
   > 而通道则是在DMA的基础上增加了能执行有限通道指令的I/O控制器，代替CPU管理控制外设。通道有自己的指令系统，是一个协处理器，他实质是一台能够执行有限的输入输出指令，并且有专门通讯传输的通道总线完成控制。

4. 将selector设置为非阻塞模式可以不断监听多个channel上的事件，可以不断轮询所有channel，从而避免发生阻塞。

5. 操作系统底层使用epoll实现，避免了原先select 只能建立连接句柄1024的限制。





































