# 8/1计网 打印

计算机网络一共有3种模型。

1. OSI七层结构
2. TCP/IP结构
3. 五层协议结构

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134035.png)

OSI是Open Systems Interconnect，也就是开放的互联系统，将复杂的互联网系统划分为不同块，方便处理。实际应用中，并没有采用这个理论模型，而是使用TCP/IP协议的四层模型。而5层模型是一个理论上的网络通信模型，方便教学的时候理解，实际上并不存在。

## 1.2 计算机网络中各层分别有什么作用？

**（1）应用层**

应用层的任务是通过**应用进程间的交互**来完成特定网络应用，常见的协议有**域名系统DNS**，万维网应用的**HTTP协议**，支持**电子邮件的SMTP协议**。把应用层交互的数据单元称为**报文**。

**（2）运输层**

为两台主机进程之间的通信提供**通用的数据传输服务。**主要包含两种协议：

- **传输控制协议 TCP**（Transmisson Control Protocol）。提供**面向连接**的，**可靠的**数据传输服务。
- **用户数据报协议 UDP**（User Datagram Protocol）。提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

**（3）网络层**

使用IP协议。网络层有两个任务：

- 把运输层产生的报文段或用户数据报**封装成分组和包进行传送**。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。注意：不要把运输层的用户数据报UDP和网络层的IP数据报弄混。
- 选择合适的路由，找到目的主机

**（4）数据链路层**

两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装程帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

**（5）物理层**

物理层的任务就是**透明地传输比特流**，换句话说实际电路传送后比特流没有发生变化。

# 2. TCP/IP协议

## 2.1 描述一下TCP/IP协议的结构

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216134831.png)

## 2.3 TCP和UDP的区别？

简单来说：

- TCP：面向连接，面向字节流，可靠，传输慢，**有流量控制阻塞控制**。
- UDP：广播形式不需要连接，面向报文，不可靠，传输快，无流量控制阻塞控制。

解释一下报文和字节流的区别：

- 字节流：**发送次数和接收次数可以不相同**，比如向水池倒了20盆水，可以开水龙头一次性全放出。
- 报文：**发送次数和接收次数必须相同**。

两者的应用场景：

- TCP：邮件，远程登录，文件传输等对准确性要求较高的地方
- UDP：及时通信，比如QQ，网络电话等。

## 2.4 三次握手和四次挥手

所谓三次握手是指**建立**一个TCP连接时，**需要客户端和服务器发送3个包**。

![img](https://i.bmp.ovh/imgs/2019/07/8dabc100eb0549e0.png)

名词解释：

- SYN：Synchronize，同步标志位，为1时表示序列号有效
- ACK：Acknowledgment，确认标志位
- seq：Synchronize Sequence Number，同步序列号
- ack：确认序列号

握手过程：

1. 第一次握手：客户端发送SYN标志为1的包，以及同步序列号x，并指明打算连接的服务器端口。此时，connect进入阻塞状态。
2. 第二次握手：服务器收到后，发送SYN和ACK标志为1的包，同时也发送一个自己的同步序列号y，外加一个确认序列号ack=x+1。此时accept进入阻塞状态。
3. 第三次握手：客户端收到后，再次发送ACK=1，以及同步序列号seq和确认序列号ack，与此同时，connect返回。当服务器收到ACK=1时，accept返回。



指**中断**连接时需要发送4个包，此**时客户端和服务器均可主动发起**挥手操作，只需要调用close()函数即可。

![img](https://i.bmp.ovh/imgs/2019/07/074e5304e133a22c.png)

B收到FIN结束消息时，干两件事：发送确认标志和通知其他进程准备关闭（这也是为什么要多一次挥手）。当准备完毕时，发送FIN。

A收到FIN时，也干两件事：发送确认标志和等待2MSL(Maximum Segment Lifetime)

**为什么不能用两次握手连接**

三次握手完成两个重要功能：

- 双方都知道彼此已经准备好
- 确认彼此的序列号

1. 假设只有两次握手，A向B发送连接请求，B收到后回复消息，B认为此时已经连接成功，开始发送数据。然而，如果B的回复消息丢失了，A没有收到确认消息，只有再次发送连接请求，而此时B有在向A发送数据，这样就会造成**死锁**。
2. 另一种情况就是 请求的数据包在网络中滞留，导致在关闭连接后，重新发送给b，使得b以为a想要重新创建一个连接。也会造成死锁。

**为什么连接是三次握手，而关闭时是四次？**

关闭连接时，服务端需要回复两次

- 第一次告诉客户端，我已经收到了你的请求了，但我的剩余报文还没有处理完，等一等。客户端收到后不再发送请求，开始默默等待。
- 第二次告诉客户端处理完成。

**为什么TIME_WAIT状态需要经过2MSL？**

2MSL是一次发送和回复的最大时间，客户端最后一次发送ACK可能会丢失，如果此时冒然关闭，会导致服务器没收到ACK，然后一直发一直发。所以需要等2MSL，如果超过这个时间，都还没有收到服务器的信息，说明已经完成，可以关闭。



## 2.5 TCP协议如何保证可靠行

**（1）**采用三次握手四次挥手保证建立的**传输信道是可靠的**。

**（2）**采用了**ARQ自动重传请求**协议**数据传输的可靠性**。

**（3）**采用**滑动窗口**协议进行流量控制

**（4）**使用**慢开始**、**拥塞避免**、**快重传**和**快恢复**来进行**拥塞控制**

## 2.6 TCP协议如何进行流量控制？

**控制流量的前提当然需要保证正确率，因此首先要引入ARQ协议。**

无差错时，A向B发送**分组**M1，B收到M1后向A回复，A收到回复后，发送下一个M2…..

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214122158.png)

如果出现差错，B没有收到信息，自然不会回复，A等待超时后，自动重传一个信息M，这就是所谓的ARQ。

**停止等待ARQ协议信道利用率太低**，所以需要使用**连续ARQ协议**来进行改善。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123227.png)

连续ARQ协议通常是结合滑动窗口协议来使用的，发送方需要维持一个发送窗口，如下图所示：

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214123327.png)

位于发送窗口内的5个分组都可以连续发送出去，而不需要等待对方的确认，这样就提高了信道利用率。发送方每收到一个确认，就把发送窗口向前滑动一个分组的位置。

接收方一般都是采用累积确认的方式。收到几个分组后，对按序到达的最后一个分组发送确认。

下载时我们的速度一般都是由慢变快，原因就是拥塞控制。

## 2.7 TCP协议如何进行拥塞控制？

网络拥塞是指在**分组交换网络中传送分组的数目太多**时，由于存储转发节点的资源有限而造成网络传输性能下降的情况。

常见的拥塞控制有：

- 慢开始
- 拥塞避免
- 快重传
- 快恢复

发送方维持一个叫做拥塞窗口cwnd（congestion window）的状态变量。当cwndssthresh时，改用拥塞避免算法。

**慢开始：**不要一开始就发送大量的数据，由小到大逐渐增加拥塞窗口的大小。

**拥塞避免：**拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1而不是加倍。这样拥塞窗口按线性规律缓慢增长。

**快重传：**我们可以剔除一些不必要的拥塞报文，提高网络吞吐量。比如接收方在**收到一个失序的报文段后就立即发出重复确认，而不要等到自己发送数据时捎带确认。**快重传规定：发送方只要**一连收到三个**重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214125708.png)

**快恢复：**主要是配合快重传。当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半（为了预防网络发生拥塞），但**接下来并不执行慢开始算法**，因为如果网络出现拥塞的话就不会收到好几个重复的确认，收到三个重复确认说明网络状况还可以。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214130136.png)

# 3. DNS协议和ARP协议

为什么这两个要放在一起说呢？因为这两个协议都是用于地址间的转化，都是起到了翻译官的职责。

## 3.1 DNS解析过程是什么？

DNS (Domain Name System) 是 **域名系统** 的英文缩写，是一种组织成域层次结构的计算机和网络服务命名系统，它用于 TCP/IP 网络，它从事将主机名或域名转换为实际 IP 地址的工作，类似于**翻译官**。

DNS查询时优先考虑**本地的Host文件**和**本地的DNS解析器**是否保留有缓存映射，如果没有就**向上一级请求**。依次按照**DNS根服务器，DNS顶层服务器，DNS管理方服务器**的顺序请求。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200120162326.png)

## 3.1 什么是MAC地址？

MAC地址是数据链路层和物理层使用的地址是**硬件地址**，IP地址网络层和以上各层使用的地址，是一种**逻辑地址**。在发送数据时，数据从高层到低层，然后才到通信链路上传输。使用IP地址的IP数据报一旦交给了数据链路层，就被封装成了MAC帧。**MAC帧在传送时使用的源地址和目的地址都是硬件地址。**

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216103838.png)

## 3.2 ARP协议工作机制是什么？

**ARP（Address Resolution Protocol）即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址**。

在每台安装有TCP/IP协议的电脑或路由器里都有一个ARP缓存表，表里的IP地址与MAC地址是一对应的，如下表所示。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104026.png)

解析MAC地址时，主机A首先在其ARP高速缓存中查找有无主机B的IP地址。

如果没有就就向**本地网段发起一个ARP请求的广播包**，查询此目的主机对应的MAC地址。网络中所有的主机收到这个ARP请求后，会检查数据包中的目的IP是否和自己的IP地址一致。如果相同，该主机首先**将发送端的MAC地址和IP地址添加到自己的ARP列表中**，如果ARP表中已经存在该IP的信息，则将其覆盖，然后给源主机发送一个ARP响应数据包，**告诉对方自己是它需要查找的MAC地址**。

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200216104350.png)

收到后**在其ARP高速缓存中写入主机B的IP地址到硬件地址的映射**。并且采用LRU机制，及时淘汰。

# 4. HTTP协议

## 4.1 HTTP常见的状态码有哪些？

![img](https://uk-1259555870.cos.eu-frankfurt.myqcloud.com/20200214133230.png)

## 4.2 HTTP协议和其他协议之间的关系是什么？

HTTP(超文本传输协议)是利用TCP在两台电脑(通常是Web服务器和客户端)之间传输信息的协议。**如果TCP是高速路，HTTP就是卡车**。Socket是对TCP/IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们能方便地使用TCP/IP协议。

## 4.3 解释一下HTTP长连接和短连接

短连接：客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。

长连接：客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。有一个保持时间

## 4.4 HTTP和HTTPS的区别

HTTP：运行在TCP之上，明文传输，客户端与服务器端都无法验证对方的身份

HTTPS：Https是身披SSL(Secure Socket Layer)外壳的Http，运行于SSL上，SSL运行于TCP之上，是添加了加密和认证机制的HTTP

## 4.5 GET和POST的区别

1. GET用于从服务器获取资源，POST用于更新服务器的资源
2. GET不会改变服务器的资源，而POST会
3. GET请求的数据会附在URL之后，比如`http:localhost:8080/id=101?`，而POST的数据则是放在请求体中。因此，GET不安全，GET的长度受限制。

## 4.6 Cookie和Session的区别

Cookie和Session都是客户端与服务器之间保持状态的解决方案，具体来说，**cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。**

Cookie实际上是**一小段文本信息**。客户端请求服务器，如果服务器需要记录该用户状态，就向客户端浏览器颁发一个Cookie。**客户端浏览器会把Cookie保存起来**。当浏览器再请求该网站时，浏览器把请求的网址连同该Cookie一同提交给服务器，服务器检查该Cookie，以此来辨认用户状态。

Session的区别在于，**会话状态完全保存在服务器**。客户端请求服务器，如果服务器记录该用户状态，就获取Session来保存状态，这时，如果服务器已经为此客户端创建过session就按照sessionid把这个session检索出来使用。服务器Session常常依赖于Cookie机制检索ID，但Cookie被禁用时也有其他方法比如URL重写机制。

## 4.7 HTTP请求报文和响应报文的格式

请求报文格式：

1. 请求行（请求方法+URI协议+版本）
2. 请求头部
3. 空行
4. 请求主体

```http
GET/sample.jspHTTP/1.1 请求行
Accept:image/gif.image/jpeg, 请求头部
Accept-Language:zh-cn
Connection:Keep-Alive
Host:localhost
User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0)
Accept-Encoding:gzip,deflate

username=jinqiao&password=1234 请求主体
```

HTTP

Copy

响应报文：

1. 状态行（版本+状态码+原因短语）
2. 响应首部
3. 空行
4. 响应主体

```http
HTTP/1.1 200 OK
Server:Apache Tomcat/5.0.12
Date:Mon,6Oct2003 13:23:42 GMT
Content-Length:112

<html>
    <head>
        <title>HTTP响应示例<title>
    </head>
    <body>
        Hello HTTP!
    </body>
</html>
```

## 4.8 HTTP1.1和2.0

1.1新功能

- 支持长链接
- 通过虚拟站点技术能够使不同域名配置在同一个IP地址的服务器上

2.0新功能

- 可以使用同一个连接并行发送多个请求和相应，可以**承接双向数据流**
- 允许设定数据流中不同资源的**优先级**，明确资源处理的先后顺序
- 打破了请求-响应的束缚，除了最初的请求响应外，服务器还能向客户端**推送额外的资源**（客户端没有明确要求的情况下）

# 5. IP地址



