# 开篇词

## To Be a HTTP Hero



# 破冰篇

## 时势与英雄：HTTP的前世今生

讲解了HTTP发展的趋势 从HTTP 0.9到HTTP1.0（不作为正式使用）到HTTP1.1 （现在主流）到HTTP2 （2014产生）到HTTP3（QUIC协议推动发展） HTTP2和HTTP3主要是由谷歌需求推动协议发展。

### **HTTP0.9** 

1. 采用纯文本形式
2. 只允许使用GET获取资源，获得后就断开连接

### **HTTP1.0**

1. 增加了 HEAD、POST 等新方法；
2. 增加了响应状态码，标记可能的错误原因；
3. 引入了协议版本号概念；
4. 引入了 HTTP Header（头部）的概念，让 HTTP 处理请求和响应更加灵活；
5. 传输的数据不再仅限于文本。

### **HTTP1.1** 

1. 增加了 PUT、DELETE 等新的方法；
2. 增加了缓存管理和控制；
3. 明确了连接管理，允许持久连接；
4. 允许响应数据分块（chunked），利于传输大文件；
5. 强制要求 Host 头，让互联网主机托管成为可能。

> 缓存管理和控制：当浏览器获得资源后，服务器回传资源有效时间，浏览器将参数放在Cache-Control中下次请求时判断缓存是否过期再次请求	

### **HTTP2**

1. 二进制协议，不再是纯文本；
2. 可发起多个请求，废弃了 1.1 里的管道；
3. 使用专用算法压缩头部，减少数据传输量；
4. 允许服务器主动向客户端推送数据；
5. 增强了安全性，“事实上”要求加密通信。

### **HTTP3** 





## HTTP是什么？HTTP又不是什么？



HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。



## HTTP世界全览（上）：与HTTP相关的各种概念

![image-20200424162001087](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200424162002.png)



1. 互联网上绝大部分资源都使用 HTTP 协议传输；
2. 浏览器是 HTTP 协议里的请求方，即 User Agent；
3. 服务器是 HTTP 协议里的应答方，常用的有 Apache 和 Nginx；
4. CDN 位于浏览器和服务器之间，主要起到缓存加速的作用；
5. 爬虫是另一类 User Agent，是自动访问网络资源的程序。



## HTTP世界全览（下）：与HTTP相关的各种协议

![image-20200424162946245](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200424162947.png)

因为 HTTPS 相当于“HTTP+SSL/TLS+TCP/IP”，其中的“HTTP”和“TCP/IP”我们都已经明白了，只要再了解一下 SSL/TLS，HTTPS 也就能够轻松掌握。

SSL 的全称是“**S**ecure **S**ocket **L**ayer”，由网景公司发明，当发展到 3.0 时被标准化，改名为 TLS，即“**T**ransport **L**ayer **S**ecurity”，但由于历史的原因还是有很多人称之为 SSL/TLS，或者直接简称为 SSL。

SSL 使用了许多密码学最先进的研究成果，综合了对称加密、非对称加密、摘要算法、数字签名、数字证书等技术，能够在不安全的环境中为通信的双方创建出一个秘密的、安全的传输通道，为 HTTP 套上一副坚固的盔甲。

### **代理的作用**

1. 负载均衡：把访问请求均匀分散到多台机器，实现访问集群化；
2. 内容缓存：暂存上下行的数据，减轻后端的压力；
3. 安全防护：隐匿 IP, 使用 WAF 等工具抵御网络攻击，保护被代理的机器；
4. 数据处理：提供压缩、加密等额外的功能。





## 常说的“四层”和“七层”到底是什么？“五层”“六层”哪去了？

TCP是有状态的协议，发送数据前双方必须建立连接，由此可以保证传输字节流 是连续的而且没有重复。UDP是没有状态的协议，发送前不需要建立连接。UDP发送的数据包是无序的，且乱序收的。

CDN处于应用层 （一开始以为处于网络层，果然对于请求处理层数越少越好）





## 域名里有哪些门道

1. 域名使用字符串来代替 IP 地址，方便用户记忆，本质上一个名字空间系统；
2. DNS 就像是我们现实世界里的电话本、查号台，统管着互联网世界里的所有网站，是一 个“超级大管家”； 
3. DNS 是一个**树状的分布式查询系统**，但为了提高查询效率，外围有多级的缓存； 
4.  使用 DNS 可以实现基于域名的负载均衡，既可以在内网，也可以在外网。

DNS域名解析的过程可以分别为本地host文件-> 本地域名服务器->根域名服务器->权威域名服务器

外围有多级缓存为大公司为了加速域名解析，会创建自己的DNS域名服务器，非权威域名服务器。作为用户DNS查询的代理，代替用户访问核心DNS。如同谷歌创建的8.8.8.8免费公共域名服务器。



## 自己动手，搭建HTTP实验环境

配置实验环境 ，同时安装了wireshak以及openresty 



# 基础篇

## 键入网址再按下回车，后面究竟发生了什么？

再简要叙述一下这次最简单的浏览器 HTTP 请求过程：

1. 浏览器从地址栏的输入中获得服务器的 IP 地址和端口号；
2. 浏览器用 TCP 的三次握手与服务器建立连接；
3. 浏览器向服务器发送拼好的报文；
4. 服务器收到报文后处理请求，同样拼好报文再发给浏览器；
5. 浏览器解析报文，渲染输出页面。

![image-20200424221950118](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200424221951.png)



## HTTP报文是什么样子的？

HTTP协议主要由以下三部分构成

1. 起始行
2. 头部字段集合
3. 消息正文

![image-20200425092339944](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425092341.png)



HTTP协议再细分可以分为 请求以及响应

**请求行**包括

- 请求方法
- 请求目标
- HTTP协议版本号

这三个部分通常用空格来进行隔开，最后用CRLF来表示结束



**状态行**包括

- HTTP协议版本
- 状态码
- 原因 （如ok等）

![image-20200425092834693](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425092836.png)

**头部字段**主要分为四大类

1. 通用字段：在请求头和响应头里都可以出现；
2. 请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附加条件；
3. 响应字段：仅能出现在响应头里，补充说明响应报文的信息；
4. 实体字段：它实际上属于通用字段，但专门描述 body 的额外信息。

**请求字段：**

Host字段：告诉服务器这个请求应该由哪个主机来处理

User-Agent字段：告诉服务器请求的客户端信息

**通用字段：**

Data字段：客户端可以使用这个时间再搭配其他字段决定缓存策略

**响应字段：**

Server字段：告诉客户端 响应服务器信息（也有部分网站不用透露信息）

**实体字段：**

content-length：表示响应体中报文body的长度

**总结**

1. HTTP 报文结构就像是“大头儿子”，由“起始行 + 头部 + 空行 + 实体”组成，简单地说就是“header+body”；
2. HTTP 报文可以没有 body，但必须要有 header，而且 header 后也必须要有空行，形象地说就是“大头”必须要带着“脖子”；
3. 请求头由“请求行 + 头部字段”构成，响应头由“状态行 + 头部字段”构成；
4. 请求行有三部分：请求方法，请求目标和版本号；
5. 状态行也有三部分：版本号，状态码和原因字符串；
6. 头部字段是 key-value 的形式，用“:”分隔，不区分大小写，顺序任意，除了规定的标准头，也可以任意添加自定义字段，实现功能扩展；
7. HTTP/1.1 里唯一要求必须提供的头字段是 Host，它必须出现在请求头里，标记虚拟主机名。



## 应该如何理解请求方法？

 HTTP/1.1 规定了八种方法

1. GET：获取资源，可以理解为读取或者下载数据；
2. HEAD：获取资源的元信息；
3. POST：向资源提交数据，相当于写入或上传数据；
4. PUT：类似 POST；
5. DELETE：删除资源；
6. CONNECT：建立特殊的连接隧道；
7. OPTIONS：列出可对资源实行的方法；
8. TRACE：追踪请求 - 响应的传输路径。

GET POST DELETE PUT  不用过多介绍

**HEAD** 

HEAD方法与 GET 方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会传回响应头，也就是资源的“元信息”。

HEAD 方法可以看做是 GET 方法的一个“简化版”或者“轻量版”。因为它的响应头与 GET 完全相同，所以可以用在很多并不真正需要资源的场合，避免传输 body 数据的浪费。

**安全与幂等**

对于安全性来说GET和HEAD是安全的，不会修改计算机的资源。剩下三种会修改或者删除计算机的资源所以不是安全的。

对于幂等性来说GET和HEAD是幂等的。同时PUT方法也是幂等的，多次修改一条记录最后的结果也是一条，而DELETE和POST则会修改数据的个数 不是幂等的。



**总结：**

1. 请求方法是客户端发出的、要求服务器执行的、对资源的一种操作；
2. 请求方法是对服务器的“指示”，真正应如何处理由服务器来决定；
3. 最常用的请求方法是 GET 和 POST，分别是获取数据和发送数据；
4. HEAD 方法是轻量级的 GET，用来获取资源的元信息；
5. PUT 基本上是 POST 的同义词，多用于更新数据；
6. “安全”与“幂等”是描述请求方法的两个重要属性，具有理论指导意义，可以帮助我们设计系统。



##  你能写出正确的网址吗？

URI，也就是**统一资源标识符**（**U**niform **R**esource **I**dentifier）

URL——**统一资源定位符**（**U**niform **R**esource **L**ocator）

URL 实在是太普及了，所以常常把这两者简单地视为相等。

URL组成的基本格式

![image-20200425141632553](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425141636.png)

浏览器会根据cheme使用默认的端口号 （HTTP 80 端口，HTTPS 443端口）

**总结**

1. URI 是用来唯一标记服务器上资源的一个字符串，通常也称为 URL；
2. URI 通常由 scheme、host:port、path 和 query 四个部分组成，有的可以省略；
3. scheme 叫“方案名”或者“协议名”，表示资源应该使用哪种协议来访问；
4. “host:port”表示资源所在的主机名和端口号；
5. path 标记资源所在的位置；
6. query 表示对资源附加的额外要求；
7. 在 URI 里对“@&/”等特殊字符和汉字必须要做编码，否则服务器收到 HTTP 报文后会无法正确处理。



## 响应状态码该怎么用？

状态码的分类为

- 1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
- 2××：成功，报文已经收到并被正确处理；
- 3××：重定向，资源位置发生变动，需要客户端重新发送请求；
- 4××：客户端错误，请求报文有误，服务器无法处理；
- 5××：服务器错误，服务器在处理请求时内部发生了错误。



**1××**

1××类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。



**2××**

2××类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。

“**200 OK**”是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。

“**204 No Content**”是另一个很常见的成功状态码，它的含义与“200 OK”基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。

“**206 Partial Content**”是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。



**3××**

3××类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的“重定向”，包括著名的 301、302 跳转。

“**301 Moved Permanently**”俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用改用新的 URI 再次访问。

与它类似的是“**302 Found**”，曾经的描述短语是“**Moved Temporarily**”，俗称“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

**4××**

4××类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的“错误码”含义了。

“**400 Bad Request**”是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，

“**403 Forbidden**”实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点

“**404 Not Found**”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到



**5××**

5××类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的“错误码”。

“**500 Internal Server Error**”与 400 类似，也是一个通用的错误码

“**501 Not Implemented**”表示客户端请求的功能还不支持

“**502 Bad Gateway**”通常是服务器作为网关或者代理时返回的错误码

“**503 Service Unavailable**”表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的“网络服务正忙，请稍后重试”的提示信息就是状态码 503



**总结**

1. 状态码在响应报文里表示了服务器对请求的处理结果；
2. 状态码后的原因短语是简单的文字描述，可以自定义；
3. 状态码是十进制的三位数，分为五类，从 100 到 599；
4. 2××类状态码表示成功，常用的有 200、204、206；
5. 3××类状态码表示重定向，常用的有 301、302、304；
6. 4××类状态码表示客户端错误，常用的有 400、403、404；
7. 5××类状态码表示服务器错误，常用的有 500、501、502、503。





## HTTP有哪些特点？

总结

1. HTTP 是灵活可扩展的，可以任意添加头字段实现任意功能；
2. HTTP 是可靠传输协议，基于 TCP/IP 协议“尽量”保证数据的送达；
3. HTTP 是应用层协议，比 FTP、SSH 等更通用功能更多，能够传输任意数据；
4. HTTP 使用了请求 - 应答模式，客户端主动发起请求，服务器被动回复请求；
5. HTTP 本质上是无状态的，每个请求都是互相独立、毫无关联的，协议不要求客户端或服务器记录请求相关的信息。

HTTP虽然是可靠的传输协议但不保证传输的时候是完全有效的，想要完全可靠，需要使用中间件消息队列等。



## HTTP有哪些优点？又有哪些缺点？

**总结**

1. HTTP 最大的优点是简单、灵活和易于扩展；
2. HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；
3. HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；
4. HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；
5. HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；
6. HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。



# 进阶篇



## 海纳百川：HTTP的实体数据（干货）

**数据类型和压缩**

当请求返回的时候，TCP和IP任务已经完成但是HTTP需要解析出响应文件的类型。同时HTTP文件内容在传输时候经常会有压缩。因此产生数据类型和压缩类型的需求。

HTTP支持**压缩类型**有：

1. gzip：GNU zip 压缩格式，也是互联网上最流行的压缩格式；
2. deflate：zlib（deflate）压缩格式，流行程度仅次于 gzip；
3. br：一种专门为 HTTP 优化的新压缩算法（Brotli）。

HTTP常见**数据类型**有：

1. text：即文本格式的可读数据，我们最熟悉的应该就是 text/html 了，表示超文本文档，此外还有纯文本 text/plain、样式表 text/css 等。
2. image：即图像文件，有 image/gif、image/jpeg、image/png 等。
3. audio/video：音频和视频数据，例如 audio/mpeg、video/mp4 等。
4. application：数据格式不固定，可能是文本也可能是二进制，必须由上层应用程序来解释。常见的有 application/json，application/javascript、application/pdf 等，另外，如果实在是不知道数据是什么类型，像刚才说的“黑盒”，就会是 application/octet-stream，即不透明的二进制数据。

HTTP 协议为此定义了两个 Accept 请求头字段和两个 Content 实体头字段，用于客户端和服务器进行“**内容协商**”。也就是说，客户端用 Accept 头告诉服务器希望接收什么样的数据，而服务器用 Content 头告诉客户端实际发送了什么样的数据。

![image-20200425160429455](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425160437.png)

## 语言类型与编码

为了解决浏览器能够解析出正确的语言。为此引入了语言类型和编码。

Accept-language：指定了用户使用想要使用的语言类型 （可有多个参数）

> Accept-Language: zh-CN, zh, en

Content-Language:返回浏览器的语言类型

> Content-Language: zh-CN

字符集在 HTTP 里使用的请求头字段是**Accept-Charset**，但响应头里却没有对应的 Content-Charset，而是在**Content-Type**字段的数据类型后面用“charset=xxx”来表示，这点需要特别注意。

![image-20200425161104951](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425161234.png)

**总结**

![image-20200425161221854](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200425161235.png)

1. 数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；
2. 数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；
3. 语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；
4. 字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；
5. 客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；
6. Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。



## HTTP传输大文件的方法

主要方法有两种，压缩以及分块传输

压缩的三种算法中gzip压缩率可以达到百分之60，而br算法对于HTML文件压缩效率在gzip基础上还可以提升百分之20。

**分块传输（重点）**

若使用分块传输那么响应报文会添加Transfer-Encoding以及Content-length。“Transfer-Encoding: chunked”和“Content-Length”这两个字段是**互斥的**，也就是说响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。

**范围请求**

HTTP 协议为了满足视频跳点观看的需求，提出了“**范围请求**”（range requests）的概念，范围请求不是 Web 服务器必备的功能，可以实现也可以不实现，所以服务器必须在响应头里使用字段“**Accept-Ranges: bytes**”明确告知客户端：“我是支持范围请求的”。



## 排队也要讲效率：HTTP的连接管理

主要内容**短连接** **长连接** **队头阻塞**

**短连接**

短连接对应版本为HTTP0.9 指使用HTTP进行通信时，两者每次传送数据都要建立TCP连接，短连接的缺点严重制约了服务器的服务能力。

**长连接**

对于短连接的缺陷，HTTP1.1提出多次请求只需建立一次TCP连接，减少服务器的消耗。使用的字段是**Connection**，值是“**keep-alive**”。长时间的空闲连接也会占据服务器的资源，所以长连接也需要在适当的时间关闭。通常有两种方式来在适当时间关闭请求，**在一定请求后关闭连接**   **在设定空闲时间内无请求关闭连接** 

**队头阻塞**

队头阻塞主要是因为网络模型为“请求-应答”模型。前面的未响应请求对阻塞后方请求。对于HTTP来说可以使用 **并发连接**来解决，对于同一个域名建立多个连接。（多个连接会加剧服务器资源消耗被服务器当成攻击拒绝连接）

**总结**

1. 早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；
2. HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；
3. 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
4. 报文头里如果有“Connection: close”就意味着长连接即将关闭；
5. 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
6. “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。



## HTTP的重定向和跳转（干货）

在网页中由用户主动发起请求的跳转称为 **主动跳转**，用户无法控制的称为 **被动跳转** ，同时也被称为 **重定向**

![image-20200425212750598](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200425212750598.png)



这里出现了一个新的头字段“Location: /index.html”，它就是 301/302 重定向跳转的秘密所在。

“**Location**”字段属于响应字段，必须出现在响应报文里。但只有配合 301/302 状态码才有意义，它**标记了服务器要求重定向的 URI**。

对于站内的链接可以使用 **相对URl**  站外的链接必须使用 **绝对URI**

**301 以及 302**

在重定向状态码中重用的分别为301以及302。 301称为“永久重定向” 302称为“临时重定向” 。

**永久重定向**指当运行服务器进行更新以及修改，资源位置完全改变时使用

**临时重定向**指当系统进行维修或者在服务降级时进行调用

对于浏览器来说 **永久和临时**的区别在于对于永久性的重定向，浏览器下次该地址时会进行优化。对于临时，浏览器在下次访问的时候只会认为该地址暂时无法使用，下次请求时仍会使用原来URL。



## HTTP的Cookie机制（干货）





















