





# 开篇词丨SQL可能是你掌握的最有用的技能

简介并没有很多东西介绍

# 1丨了解SQL：一门半衰期很长的语言

sql规范

1. 表名、表别名、字段名、字段别名等都小写；
2. SQL 保留字、函数名、绑定变量等都大写。

# 02丨DBMS的前世今生

为什么存在这么多的DBMS(数据库管理系统)

![image-20200511012745046](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511012747.png)

# 03丨学会用数据库的方式思考SQL是如何执行的

不同的数据库但是在每条sql语句进行执行的时候步骤流程不一样，但是具体的几个重要步骤都是一样的。

在oracle中有以下几个步骤

![image-20200511195752687](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511195802.png)

1. 语法解析
2. 语义解析
3. 权限检查
4. 共享池检查
5. 分为两个部分
   1. 硬解析 优化器 优化 执行
   2. 软解析 执行

> 软解析是指当前这条sql是已经进行解析过并且已经存储在缓存中 就直接执行
>
> 硬解析是指语句第一次被执行 需要被sql优化器进行优化

在oracle中可以使用绑定变量来减少硬解析 



mysql中一条指令如何执行

mysql中分为 连接层 sql层 存储引擎层 

![image-20200511200927072](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511200929.png)

其中sql层为主要的部分

![image-20200511201012065](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511201013.png)

分为以下几个部分

1. 查询缓存 但效率不高在8.0之后被抛弃使用
2. 解析器：语法解析 语义解析 
3. 优化器： 选择优化的索引
4. 执行器：执行结果将结果返回缓存

mysql 存储引擎主要有

- innodb ：5.5之后的默认引擎 ，特点支持事务，支持行级锁，支持外键约束
- myisam：速度快占用资源少





# 04丨使用DDL创建数据库&数据表时需要注意什么？



数据库表常见的约束

1. 主键约束
2. 外键约束：一个表中的外键对应于另一张表的主键
3. 唯一性约束
4. not null 约束
5.  check约束 （范围约束）
6. default （默认值约束）

设计原则

1. 表少
2. 字段少 在数据冗余和检索效率之间进行平衡
3. 联合主键的字段个数少好（索引占据一定的空间）
4. 使用更多的主键和外键





# 05丨检索数据：你还在SELECT * 么？

sql 关键字执行的顺序

![image-20200511204606264](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511204607.png)

为什么不推荐使用select *进行查询 因为查询出冗余的数据会导致网络传输量变大。



# 06丨数据过滤：SQL数据过滤都有哪些方法？

基础篇 没有特别重要的部分

使用%通配符进行匹配时候，若%在一个字段的前面这时候会走全表扫描

> 比如使用`LIKE '%太%'`或`LIKE '%太'`的时候就会对全表进行扫描。如果使用`LIKE '太%'`，同时检索的字段进行了索引的时候，则不会进行全表扫描。



# 07丨什么是SQL函数？为什么使用SQL函数可能会带来问题？

sql内置的函数主要分为以下四类

- 算术函数
- 日期函数
- 字符串函数
- 转换函数
- 聚集函数

大小写规范问题

比如 MySQL 在 Linux 的环境下，数据库名、表名、变量名是严格区分大小写的，而字段名是忽略大小写的。

而 MySQL 在 Windows 的环境下全部不区分大小写。

# 08丨什么是SQL的聚集函数，如何利用它们汇总表的数据？

where 和having的区别是什么？

where是对数据行进行 分组，而having是对分组后的组进行分组



# 09丨子查询：子查询的种类都有哪些，如何提高子查询的性能？

exists和in的效果相同，这时候需要根据两张表的大小进行选择使用in还是exists ，类比left join 以及 rigth join的不同场景 可以得出当主表大的时候使用in 效率更好，主表小的时候 exists 效率更好 

# 10丨常用的SQL标准有哪些，在SQL92中是如何使用连接的？

五种连接方式

- 笛卡尔连接
- 等值连接
- 非等值连接
- 外连接（左连接，右连接）
- 自连接 对同一个表进行操作，查询条件使用了当前表的字段



# 11丨SQL99是如何使用连接的，与SQL92的区别是什么？

交叉连接  cross join 类似于笛卡尔连接

等值连接可以使用 on 关键字也可以使用using连接

![image-20200511215520525](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511215522.png)

# 12丨视图在SQL中的作用是什么，它是怎样工作的？

![image-20200511220819666](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200511220823.png)

视图的作用：在复杂项目中，在数据表比较复杂的情况下可以将经常查询的数据放入到视图中，提升查询和使用效率

视图的作用：简化复杂的SQL查询，让sql更加清爽易用





# 13丨什么是存储过程，在实际项目中用得多么？

暂时跳过 没有很看懂



# 14丨什么是事务处理，如何使用COMMIT和ROLLBACK进行操作？

事务特性：

- 原子性
- 一致性
- 隔离性
- 持久性



# 15丨初识事务隔离：隔离的级别有哪些，它们都解决了哪些异常问题？

脏读：读到事务未提交的数据（一次读取）

不可重复读：先进行读取，后读到事务未提交的数据 （修改的场景，二次读取 重点在于delete 和update）

幻读：先进行数据库记录数量读取，后读到数据库记录数量改变（新增或者减少的场景 两次读取 重点在于insert）

四种事务隔离级别

- 读未提交  
- 读已提交 解决脏读问题 （oracle 和 sql server 默认隔离级别）
- 可重复读 解决脏读以及不可重复读问题 （mysql 的默认隔离级别）
- 串行化 解决幻读问题



# 16丨游标：当我们需要逐条处理数据时，该怎么做？

# 17丨如何使用Python操作MySQL？

# 19丨基础篇总结：如何理解查询优化、通配符以及存储过程？









调优篇

# 20丨当我们思考数据库调优的时候，都有哪些维度可以选择？

表字段类型选择如果可以使用数值型就不要使用字符型， 表字段长度尽量设计的小，**多表联查的时候可以使用反范式进行优化**

垂直分表:将一张表进行列拆分 （按照列进行拆分，将经常使用的列放在一张表里面）

水平分表:将一张表进行行拆分（按照行进行拆分，一张表记录数拆分为多张表）

# 21丨范式设计：数据表的范式有哪些，3NF指的是什么？

一般来说数据表的设计应尽量满足 3NF。但也不绝对，有时候为了提高某些查询性能，我们还需要破坏范式规则，也就是反规范化。

1NF指的是数据库表中任何属性都是原子性不可再分的

2NF指的是数据库里的非主属性都要和数据表中的候选键有完全依赖关系（完全依赖问题）

3NF指的是对于任何非主属性都不传递依赖于候选键（传递依赖问题）

# 22丨反范式设计：3NF有什么不足，为什么有时候需要反范式设计？

反范式化设计是相对范式化设计而言，通过少量的冗余通过时间来换取空间。



# 23丨索引的概览：用还是不用索引，这是一个问题

索引跟索引列的重复度有一定的关系

索引跟数据库表的行数有一定的关系

功能逻辑索引的种类有哪些？

1. 普通索引:基础索引
2. 唯一索引:在普通索引上添加唯一条件
3. 主键索引:在唯一索引上添加不为null条件
4. 全文索引:目前只支持英文 使用专门的全文搜索引擎

物理实现索引种类有

1. 聚集索引 表中的数据行按索引的排序方式进行存储（一张表只能有一个聚集索引）
2. 非聚集索引 两次查找，第一次先找到索引对应的位置，然后第二次从索引对应位置获取到查找的数据

两者的区别

- 聚集索引的叶子节点存储的是数据记录，非聚集索引叶子节点保存的是数据位置
- 一张表只能一个聚集索引，多个非聚集索引，聚集索引和物理磁盘排列有关系
- 聚集索引数据的查询效率比较高，但如果对数据进行插入或者删除更新等操作效率会比非聚集索引低。



按照字段个数进行划分

- 单一索引
- 联合索引

最左匹配原则

# 24丨索引的原理：我们为什么用B+树来做索引？

二叉树 -> 退化为单向链表

平衡二叉树 -> 磁盘io消耗时间比较多

B树 ->M多叉树 减少读取磁盘次数 

B+树相对与B树对比

1. B+树中 有k个孩子节点就有k个关键字 在B树中，孩子数量等于关键字+1
2. 非叶子节点的关键字也会同时出现在子节点中
3. 非叶子节点仅用于索引，不保存数据，跟记录有关的信息都放在叶子节点中，而B树中非叶子节点既保存索引也保存数据记录
4. 所有关键字都在叶子节点出现，叶子节点构成一个有序链表。

为什么使用b+树 而不是b树

1. b+数非叶子节点 所需要的磁盘io更少。同样的磁盘页，b+树可以存储更多节点关键字。
2. 范围查询b+树的效率比b树更高 因为b+树通过有序链表进行链接。而B树需要通过中序遍历才能完成范围的查找

![image-20200512212204737](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200512212206.png)

# 25丨Hash索引的底层原理是什么？



hash索引和B+索引的区别

1. hash不支持范围查询，B+支持范围查询。
2. hash不支持联合索引的最左匹配原则，hash是通过对联合索引的每个键值合并进行hash计算，不会针对每个索引单独计算hash值。因此如果用到联合索引的一个或者几个索引，联合索引无法被引用。
3. hash索引不支持order by 排序，同时hash索引也不支持模糊查询

![image-20200512215445663](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200512215447.png)

# 26丨索引的使用原则：如何通过索引让SQL查询效率最大化？

可能创建索引的场景 

1. 字段的数值有唯一性的限制
2. 频繁作为where 查询条件的字段尤其是在数据表大的情况下
3. 经常需要 group by 和order by 的列
4. 多条件联合查询的时候最好使用联合索引
5. update 、delete的where条件列，一般也需要创建索引
6. Distinct字段建立索引

> 频繁更新的字段是不需要建立索引的

索引失效的场景

1. 索引使用表达式计算
2. 索引使用函数也会造成失效
3. 在where 子句中，如果在or前的条件列进行索引，而在or后的条件列没有进行索引，那么索引就会失效
4. 使用like 模糊查询的时候，后面不能是%
5. 使用联合索引的时候注意最左原则

![image-20200512221737295](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200512221739.png)

# 27丨从数据页的角度理解B+树查询

**在数据库中，不论读一行，还是读多行，都是将这些行所在的页进行加载。也就是说，数据库管理存储空间的基本单位是页（Page）。**

![image-20200512222148152](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200512222148152.png)

**2. 普通索引和唯一索引在查询效率上有什么不同？**

我们创建索引的时候可以是普通索引，也可以是唯一索引，那么这两个索引在查询效率上有什么不同呢？

唯一索引就是在普通索引上增加了约束性，也就是关键字唯一，找到了关键字就停止检索。而普通索引，可能会存在用户记录中的关键字相同的情况，根据页结构的原理，当我们读取一条记录的时候，不是单独将这条记录从磁盘中读出去，而是将这个记录所在的页加载到内存中进行读取。InnoDB 存储引擎的页大小为 16KB，在一个页中可能存储着上千个记录，因此在普通索引的字段上进行查找也就是在内存中多几次“判断下一条记录”的操作，对于 CPU 来说，这些操作所消耗的时间是可以忽略不计的。所以对一个索引字段进行检索，采用普通索引还是唯一索引在检索效率上基本上没有差别。





# 28丨从磁盘I/O的角度理解SQL查询的成本

1. 位置决定效率。如果页就在数据库缓冲池中，那么效率是最高的，否则还需要从内存或者磁盘中进行读取，当然针对单个页的读取来说，如果页存在于内存中，会比在磁盘中读取效率高很多。
2. 批量决定效率。如果我们从磁盘中对单一页进行随机读，那么效率是很低的（差不多 10ms），而采用顺序读取的方式，批量对页进行读取，平均一页的读取效率就会提升很多，甚至要快于单个页面在内存中的随机读取。

# 29丨为什么没有理想的索引？

窄索引和宽索引的区别是where 条件中 索引列的个数 

如果个数>2 则为宽索引否则为窄索引。使用宽索引虽然多次进行索引增加了时间消耗，但是可以避免回表提升sql查询的效率

# 30丨锁：悲观锁和乐观锁是什么？



锁粒度划分 

- 行锁：锁粒度小，发生锁冲突概论低，可以实现的并发度高，锁开销大容易出现死锁情况
- 页锁：一个页锁包含多个行锁，并发程度一般，也会出现死锁的情况
- 表锁: 粒度最大， 冲突概论较高，并发度低，对锁的使用开销小，加锁快

锁占据一定的内存空间，会进行锁升级

意向锁：对于小粒度的数据加锁后，默认对于更粗粒度的数据添加上了锁

共享锁发生死锁的情况：两个客户端分别获取读锁，其中一个客户端2需要对数据进行修改而另外一个1不进行修改，这个时候会造成客户端2修改操作延迟，重新执行事务。



**乐观锁**（Optimistic Locking）认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上，我们可以采用版本号机制或者时间戳机制实现。

**悲观锁**（Pessimistic Locking）也是一种思想，对数据被其他事务的修改持保守态度，会通过数据库自身的锁机制来实现，从而保证数据操作的排它性。

![image-20200512235058978](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200512235100.png)

1. 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。
2. 悲观锁适合写操作多的场景，因为写的操作具有排它性。采用悲观锁的方式，可以在数据库层面阻止其他事务对该数据的操作权限，防止读 - 写和写 - 写的冲突。



# 31丨为什么大部分RDBMS都会支持MVCC？

![image-20200513213608661](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200513213608661.png)

mvcc通过不采用锁的方式，通过乐观锁 来解决不可重复读和幻读问题。提升系统的系统



![image-20200513213843026](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513213844.png)

mvcc 解决的问题：

1. 读写之间阻塞的问题，通过mvcc可以让读不阻塞写，写不阻塞读，这样就可以提升事务并发处理能力
2. 降低了死锁的概率，采用乐观锁，读取数据不需要加锁，写数据的时候只用行锁
3. 解决一致性的问题，快照读，查询数据库某个时间点的快照，只能看到这个时间点之前事务提交的结果，不能看到这个时间点之后事务提交的更新结果



快照读和当前读

**InnoDB 中的 MVCC 是如何实现的？**

事务版本号，开启一个事务按照递增的顺序获取一个事务id，通过id可以判断事务的时间顺序

行记录的隐藏列：

![image-20200513215603855](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513215605.png)

row_id ：隐藏的行ID用来生成默认的聚集索引

trx_id: 操作这个事务的ID

db_roll_ptr:回滚指针，指向这个记录的undo log信息

![image-20200513215745533](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513215746.png)

**read-view**解决一致性问题

其中有几个属性是比较重要的

1. trx_ids ：系统当前正在活跃事务Id集合
2. low_limit-id :活跃事务中最大事务id
3. up_limit_id：活跃事务的中最小事务id
4. creator_trx_id:创建这个read_view的事务id

![image-20200513220510966](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513220512.png)

查询一条记录如何通过多版本并发控制技术找到

1. 首先获取事务自己的版本号，也就是事务 ID；
2. 获取 Read View；
3. 查询得到的数据，然后与 Read View 中的事务版本号进行比较；
4. 如果不符合 ReadView 规则，就需要从 Undo Log 中获取历史快照；
5. 最后返回符合规则的数据。

![image-20200513223756483](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513223758.png)

![image-20200513223912867](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513223914.png)



![image-20200513224444286](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513224445.png)

![image-20200513224514246](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513224515.png)



![image-20200513224528742](https://pic-go-youdaoyun-image.oss-cn-beijing.aliyuncs.com/pic-go-youdaoyun-image/20200513224530.png)



# 32丨查询优化器是如何工作的？

优化器分为两个部分：

1. 逻辑优化
2. 物理优化

# 33丨如何使用性能分析工具定位SQL执行慢的原因？



# 38丨初识Redis：Redis为什么会这么快？

redis快的原因

1. 底层使用 c语言编写
2. 基于内存  减少网络磁盘io
3. 单进程单线程  使用io多路复用避免上下文切换
4. 使用key-value的数据结构

todo 跳表不是很懂







# 39丨如何使用Redis来实现多用户抢票问题







































































