# 第一章 高并发时代必备技能

1.1-1.4 介绍了redis netty 以及zookeeper 优势以及作用

1.5 介绍了一个12天了解netty zookeeper 以及redis 的实践计划



# 第二章 高并发IO的底层原理

IO读写的基础原理 

底层的io 通过系统缓存区（内核缓存区）和进程缓存区（用户缓存区 ）来实现io数据的读写。使用缓冲区的主要原因是减少多次io造成的资源消耗如线程上下文切换等。

IO读写举例 

分为两个阶段，网卡将请求的的数据从进程缓冲区读到内核中，内核将数据复制到进程缓冲区中。获取到数据后在java线程中进行业务逻辑处理，将处理完的数据再次写到内核缓冲区中，内核创建网络io将数据返回请求客户端。



四种主要io模型

同步阻塞io

同步非阻塞io

io多路复用 （nio java中）

异步io



通过合理配置来支持百万级并发连接



# 第3章 Java NIO通信基础详解

buffer（缓冲区） channel（通道） selector（选择器）是NIO的三大组件

NIO newio 相对来说相反是oio，传统的io是同步阻塞。NIO提出的io多路复用，让服务器io接收新的连接操作变为异步执行，NIO可以通过 选择器（也可以说成：多路复用器），后续不断地轮询选择器的选择 键集合，选择新到来的连接。SocketChannel传输通道的读写操作都是异步的。 如果没有可读写的数据，负责IO通信的线程不会同步等待。这样，线 程就可以处理其他连接的通道；不需要像OIO那样，线程一直阻塞， 等待所负责的连接可用为止。





# 第4章 鼎鼎大名的Reactor反应器模式

**4.1 Reactor反应器模式为何如此重要**

**4.1.1 为什么首先学习Reactor反应器模式**

反应器模式由Reactor反应器线程、Handlers处理器两大角色组
成：
（1）Reactor反应器线程的职责：负责响应IO事件，并且分发到 Handlers处理器。
（2）Handlers处理器的职责：非阻塞的执行业务处理逻辑。

**4.1.3 多线程OIO的致命缺陷**

为了解决这个严重的连接阻塞问题，出现了一个极为经典模式： Connection Per Thread（一个线程处理一个连接）模式。

对于每一个新的网络连接都分配给一个线程。每个线程都独自处 理自己负责的输入和输出。当然，服务器的监听线程也是独立的，任 何的socket连接的输入和输出处理，不会阻塞到后面新socket连接的监 听和建立。早期版本的Tomcat服务器，就是这样实现的。

Connection Per Thread模式（一个线程处理一个连接）的优点是： 解决了前面的新连接被严重阻塞的问题，在一定程度上，极大地提高 了服务器的吞吐量.

Connection Per Thread模式的缺点是：对应于大量的连接，需要耗 费大量的线程资源，对线程资源要求太高。在系统中，线程是比较昂 贵的系统资源。如果线程数太多，系统无法承受。而且，线程的反复 创建、销毁、线程的切换也需要代价。因此，在高并发的应用场景 下，多线程OIO的缺陷是致命的。

如何解决Connection Per Thread模式的巨大缺陷呢？一个有效路径 是：使用Reactor反应器模式。用反应器模式对线程的数量进行控制

**4.2 单线程Reactor反应器模式**

在反应器模式中，有Reactor反应器和Handler处理 器两个重要的组件：
（1）Reactor反应器：负责查询IO事件，当检测到一个IO事件， 将其发送给相应的Handler处理器去处理。这里的IO事件，就是NIO中 选择器监控的通道IO事件。
（2）Handler处理器：与IO事件（或者选择键）绑定，负责IO事 件的处理。完成真正的连接建立、通道的读取、处理业务逻辑、负责 将结果写出到通道等。

**4.2.1 什么是单线程Reactor反应器**

简单地说，Reactor反 应器和Handers处理器处于一个线程中执行。它是最简单的反应器模 型

![image-20200419231828677](C:\Users\caopeng\AppData\Roaming\Typora\typora-user-images\image-20200419231828677.png)



基于Java NIO，如何实现简单的单线程版本的反应器模式呢？需要 用到SelectionKey选择键的几个重要的成员方法：
方法一：void attach(Object o)
此方法可以将任何的Java POJO对象，作为附件添加到SelectionKey 实例，相当于附件属性的setter方法。这方法非常重要，因为在单线程 版本的反应器模式中，需要将Handler处理器实例，作为附件添加到 SelectionKey实例。
方法二：Object attachment()
此方法的作用是取出之前通过attach(Object o)添加到SelectionKey选 择键实例的附件，相当于附件属性的getter方法，与attach(Object o)配套 使用。
这个方法同样非常重要，当IO事件发生，选择键被select方法选 到，可以直接将事件的附件取出，也就是之前绑定的Handler处理器实 例，通过该Handler，完成相应的处理。

