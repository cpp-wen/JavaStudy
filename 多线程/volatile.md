# volatile关键字源码分析

volatile关键字不能代替synchronized 关键字的原因是，volatile只能保证可见性和有序性，不能保证原子性。所以无法替代synchronized。

## 原子性:

在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的。其他的语句会被解析成多条指令，无法保证原子性。

接下里了解volatile是如何实现可见性和有序性即可。

## 可见性：

当一个线程对共享变量进行修改，其他变量可以获得修改后的变量，而不是先前的缓存数据值。

1.先从操作系统本身添加缓存来提升cpu计算速度来说

2.为了解除缓存的问题引入两个方法 1.缓存一致性协议 2.总线加lock锁

3.缓存一致性原理，在物理上实现原理是 被volatile修饰的变量在总线上被处理器的嗅探判断是否过期。如果过期需要从内存中读取这个变量。同时操作变量的线程也会因为在底层添加了lock指令将缓存中的数据写回内存。

![1556270091313](https://github.com/ZXZxin/ZXBlog/raw/master/Java/Concurrence/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/assets/1556270091313.png)

## 有序性：

指令重排序指在运行时优化指令的执行的顺序。

对于单例模式来说，添加volatile关键字就是为了防止指令重排序。其中引入8条happen-before原则，其中一条为对于volatile修饰的变量写操作happen-before后续的读操作。为了满足这一条原则，JVM使用内存屏障来实现。

内存屏障有四种分别为

- storestore屏障 写操作前添加的屏障
- storeload屏障   写操作后添加的屏障
- loadload屏障    读操作后添加的屏障
- loadstore屏障    读操作后添加的屏障



8种同步操作

![1556288144232](https://github.com/ZXZxin/ZXBlog/raw/master/Java/Concurrence/%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/assets/1556288144232.png)

- `lock` ( 锁定 ) : 作用于主内存的变量，把一个变量标识为一条线程独占状态；
- `unlock` ( 解锁 ) : 作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定；
- `read` ( 读取 ) : 作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用；
- `load` ( 载入 ) : 作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中；
- `use` ( 使用) : 作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎；
- `assign` ( 歧值 ) : 作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量；
- `store` ( 存储 ) : 作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作；
- `write` ( 写入 ) : 作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中；



volatile的内存屏障插入策略非常保守，其实在实际中，只要不改变volatile写-读得内存语义，编译器可以根据具体情况优化，省略不必要的屏障。



----





操作系统内部原因：

有了CPU高速缓存虽然解决了效率问题，但是它会带来一个新的问题：数据一致性。在程序运行中，会将运行所需要的数据复制一份到CPU高速缓存中，在进行运算时CPU不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后才会将数据刷新到主存中。



解决缓存一致性方案有两种：

1. 通过在总线加LOCK#锁的方式
2. 通过缓存一致性协议

但是方案1存在一个问题，它是采用一种独占的方式来实现的，即总线加LOCK#锁的话，只能有一个CPU能够运行，其他CPU都得阻塞，效率较为低下。

第二种方案，缓存一致性协议（MESI协议）它确保每个缓存中使用的共享变量的副本是一致的。其核心思想如下：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该变量的缓存行是无效的，因此其他CPU在读取该变量时，发现其无效会重新从主存中加载数据。

![img](https://gitee.com/duchaochen/ycbbs.vip-1/raw/master/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%96%87%E7%AB%A0/002-images/sijava/201812082001.png)

在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的



如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存行的数据写回到系统内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现**缓存一致性**协议，**每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期**了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。

1. Lock前缀的指令会引起处理器缓存写回内存；
2. 一个处理器的缓存回写到内存会导致其他处理器的缓存失效；
3. 当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。



**观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令**。lock前缀指令其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。volatile的底层就是通过内存屏障来实现的。



