分治思想在很多领域都有广泛的应用，例如算法领域有分治算法（归并排序、快速排序都属于分治算法，二 分法查找也是一种分治算法）；大数据领域知名的计算框架MapReduce背后的思想也是分治。既然分治这 种任务模型如此普遍，那Java显然也需要支持，Java并发包里提供了一种叫做Fork/Join的并行计算框架，就 是用来支持分治这种任务模型的。

分治任务模型可分为两个阶段：一个阶段是任务分解 任务分解，也就是将 任务迭代地分解为子任务，直至子任务可以直接计算出结果；另一个阶段是结果合并 结果合并，即逐层合并子任务的 执行结果，直至获得最终结果。下图是一个简化的分治任务模型图，你可以对照着理解。

Fork/Join计算框架主要包含两部分，一部分是分治任务的 分治任务的 线程池ForkJoinPool 线程池ForkJoinPool，另一部分是分治任务ForkJoinTask 分治任务ForkJoinTask。



Fork/Join并行计算框架主要解决的是分治任务。分治的核心思想是“分而治之”：将一个大的任务拆分成小 的子任务去解决，然后再把子任务的结果聚合起来从而得到最终结果。这个过程非常类似于大数据处理中的 MapReduce，所以你可以把Fork/Join看作单机版的MapReduce。
Fork/Join并行计算框架的核心组件是ForkJoinPool。ForkJoinPool支持任务窃取机制，能够让所有线程的工 作量基本均衡，不会出现有的线程很忙，而有的线程很闲的状况，所以性能很好。Java	1.8提供的Stream API里面并行流也是以ForkJoinPool为基础的。不过需要你注意的是，默认情况下所有的并行流计算都共享 一个ForkJoinPool，这个共享的ForkJoinPool默认的线程数是CPU的核数；如果所有的并行流计算都是CPU密 集型计算的话，完全没有问题，但是如果存在I/O密集型的并行流计算，那么很可能会因为一个很慢的I/O计 算而拖慢整个系统的性能。所以建议用不同的ForkJoinPool执行不同类型的计算任务 







线程本地存储模式