### 并行和并发

![高并发编程学习(1)——并发基础](https://www.javazhiyin.com/wp-content/uploads/2019/11/java6-1574849266.jpg)

### 进程和线程

进程是指一个内存中运行的应用程序。

线程是指进程中的一个执行任务（控制单元），一个进程可以同时并发运行多个线程。

两者的区别：

**进程**：有独立的内存空间，进程中的数据存放空间（堆空间和栈空间）是独立的，至少有一个线程。

**线程**：堆空间是共享的，栈空间是独立的，线程消耗的资源也比进程小，相互之间可以影响的，又称为轻型进程或进程元。

### 上下文切换：

上下文切换是指当一个线程执行结束时要进行数据保存，并加载另一个线程所需要的资源，这个过程便称为上下文切换。



### 单线程，多线程区别联系

了解多线程出现原因

1. 单核 CPU 中，将 CPU 分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用 CPU 的机制。
2. 多线程会存在线程上下文切换，会导致程序执行速度变慢，即采用一个拥有两个线程的进程执行所需要的时间比一个线程的进程执行两次所需要的时间要多一些。

**结论：即采用多线程不会提高程序的执行速度，反而会降低速度，但是对于用户来说，可以减少用户的响应时间。**

> 具体举例 在多线程环境下的累加不一定比单线程快。也就是串行不一定慢于并行。原因就是上下文切换

### 多线程的优势

1. 优势一：资源利用率更好。当计算机在进行其他的操作时候，如文件读取，网络io时，cpu无法得到充分利用，多线程可以让cpu在等待io等操作时，让cpu进行运算处理。
2. 优势二：程序设计在某些情况下更简单。将一个大型项目分为 若干个子项目，让多线程分别运行这几个项目，就简单很多。
3. 优势三：程序响应更快。发挥多核cpu的优势，达到充分利用CPU的目的。
4. 优势四：系统创建进程时需要为该进程重新分配系统资源,创建线程则代价小很多,因此实现多任务并发时,多线程效率更高.

### 线程的六种状态

1. 新建态：当一个线程被创建但是还没有被执行时候的状态

2. 运行态：分为ready和running 调用start方法后进入ready状态去争取cpu时间片，在获取cpu后变为running状态

3. 等待态：处于等待状态的线程不会自动苏醒，只能被其他线程唤醒。 如wait方法，join方法

4. 有限等待态：但存在于限期等待的线程无需被其它线程显式唤醒，而是在等待时间结束后，系统自动唤醒。设置了timeout参数的sleep方法

5. 阻塞态：当多个线程进入同一块共享区域时，例如Synchronized块、ReentrantLock控制的区域等，会去整夺锁，成功获取锁的线程继续往下执行，而没有获取锁的线程将进入阻塞状态，等待获取锁。

6. 结束态： 已终止线程的线程状态，线程已结束执行。

   

### sleep方法和wait方法的区别

1. sleep方法由Thread类提供，wait方法由Object类提供
2. sleep方法可以在任何地方调用，而wait方法只能在Synchronized代码块中调用
3. sleep方法会让出cpu，不会是释放锁，wait方法会让出cpu同时也会释放锁

### notify和notifyAll方法的区别

1.notify可以唤醒一个处于等待状态的线程

2.notifyAll可以理解为唤醒所有等待的线程使所有处于等待状态的线程都变为ready状态，去重新争夺锁。

##### 区别

要说清楚他们的区别，首先要简单的说一下Java synchronized的一些原理，在openjdk中查看java的源码可以看到，java对象中存在monitor锁，monitor对象中包含锁池和等待池。

**锁池**，假设有多个对象进入synchronized块争夺锁，而此时已经有一个对象获取到了锁，那么剩余争夺锁的对象将直接进入锁池中。

**等待池**，假设某个线程调用了对象的wait方法，那么这个线程将直接进入等待池，而等待池中的对象不会去争夺锁，而是等待被唤醒。

**notifyAll会让所有处于等待池中的线程全部进入锁池去争夺锁，而notify只会随机让其中一个线程去争夺锁。**





### 线程池

1. 线程池的引入是用来解决在日常开发的多线程开发中，如果开发者需要使用到非常多的线程，那么这些线程在被频繁的创建和销毁时，会对系统造成一定的影响，有可能系统在创建和销毁这些线程所耗费的时间会比完成实际需求的时间还要长。
2. 在线程很多的状况下，对线程的管理就形成了一个很大的问题，开发者通常要将注意力从功能上转移到对杂乱无章的线程进行管理上，这项动作实际上是非常耗费精力的。

###### 利用Executors创建不同的线程池满足不同场景的需求

`newFixThreadPool(int nThreads)`
指定工作线程数量的线程池。

`newCachedThreadPool()`
处理大量中断事件工作任务的线程池，

`newSingleThreadExecutor()`
创建唯一的工作线程来执行任务，如果线程异常结束，会有另一个线程取代它。可保证顺序执行任务。

`newWorkStealingPool()`
内部构建ForkJoinPool，利用working-stealing算法，并行地处理任务，不保证处理顺序。





























